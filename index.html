<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>shivani singh</title>
  <link rel="icon" href="images/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="style.css">
  <style>
    #motion-permission {
      position: fixed; inset: auto 12px 12px auto;
      z-index: 9999;
      padding: 10px 14px; border-radius: 999px; border: 1px solid #ddd;
      background: rgba(255,255,255,.9); backdrop-filter: saturate(120%) blur(6px);
      font-size: 14px; box-shadow: 0 6px 20px rgba(0,0,0,.08);
      display: none;
    }
    body.dark-mode #motion-permission {
      background: rgba(24,24,24,.9); color: #eee; border-color: #333;
    }
  </style>
</head>
<body>
  <div id="controls-container">
    <button id="theme-toggle"> ⏾ </button>
    <button id="font-decrease"> - </button>
    <button id="font-increase"> + </button>
  </div>

  <h1>Hi, I'm Shivani</h1>
  <p>
    A designer with an aptitude for analytical thinking and an
    <button class="reveal highlight-yellow" onclick="expandOnce(this, 'play')">appetite for play</button><span id="play" class="inline-reveal"> — side projects and ideas in progress <a href="https://shivaniest.com" target="_blank">live here</a></span>.
    Currently shaping tech for social impact at
    <button class="reveal highlight-blue" onclick="expandOnce(this, 'unicef')">UNICEF Innovation</button><span id="unicef" class="inline-reveal"> where I <a href="https://unicef-office-of-innovation-1.gitbook.io/unicef-toolkits/HlT4xFWyVhjMRNHG534K/product-design" target="_blank">mentor</a> early-stage startups in digital product design,
    and facilitate <button class="reveal highlight-blue" onclick="expandOnce(this, 'collab')">collaboration</button>with stakeholders<span id="collab" class="inline-reveal">
    — like in this <a href="https://docs.google.com/presentation/d/e/2PACX-1vQlLTQlfvFx2dAqkBc4L7SoIxsV97rL5pg7tHB_gHclwawwWI400lErSsE3TWydCVhdCnXbkJTfBuS9/pub?start=true&loop=false&delayms=60000" target="_blank">design sprint</a> where we reimagined a needs assessment process</span></span>.
    I think of my practice as a way to bridge intention and outcome.
    Previously, I was a designer at
    <button class="reveal highlight-pink" onclick="expandOnce(this, 'sf')">Salesforce</button> in San Francisco<span id="sf" class="inline-reveal"> — explore my work in this <a href="https://docs.google.com/presentation/d/e/2PACX-1vSIAnrA-YdMMIYAmLWARmflhZkR6fjkmb--3mA7UqHA36ywzY6SGtTjLynAr35MLmpYWI_fdFcazv4S/pub?start=false&loop=false&delayms=600000" target="_blank">overview</a></span>.
    With a background in graphic design, I’ve also worked in visual communication and 
    <button class="reveal highlight-purple" onclick="expandOnce(this, 'ads')">advertising</button><span id="ads" class="inline-reveal">, crafting <a href="https://singh.work/logofolio">brand identities</a> for over five years</span>.
    <br><br>I am an alumnus of the National Institute of Design, India and
    <button class="reveal highlight-green" onclick="expandOnce(this, 'CCA')">California College of the Arts</button>, San Francisco.
    <span id="CCA" class="inline-reveal">From my time as a student, I’m especially fond of <a href="https://singh.work/case-study.html">this project</a> with an industrial arts school in Oakland. </span>
  </p>

  <p class="note">Born in India, I'm currently based in Stockholm. If you're curious to know more, find me on <a href="https://bento.me/singhshivani" target="_blank">bento</a>, or connect on <a href="https://www.linkedin.com/in/shivanidotsingh/" target="_blank">Linkedin</a>.</p>

  <p class="note" style="font-size: 0.8em; opacity: 0.5;">This website was built on github.com • Last updated on Aug 02, 2025 </p>
  
  <div id="random-dots-container"></div>
  <button id="motion-permission">Enable Tilt Control</button>

  <script>
    // --- environment detect ---
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    // --- reveal + collect ---
    let clickedContentIds = new Set();
    const totalHighlights = 6;
    const perColorCap = 250;
    const TOTAL_CAP = 1500;
    let dotCreateCounter = 0; // for alternating spawn flag

    const highlightColors = {
      'highlight-yellow': '#FDFB8C',
      'highlight-blue':   '#D6F5FF',
      'highlight-pink':   '#FFDDEE',
      'highlight-green':  '#DDFFAA',
      'highlight-purple': '#EEDDFF'
    };

    function expandOnce(buttonElement, contentId) {
      const contentEl = document.getElementById(contentId);
      contentEl.classList.add('visible');
      buttonElement.disabled = true;
      clickedContentIds.add(contentId);

      const c = document.getElementById('random-dots-container');
      const dot = document.createElement('span');
      dot.classList.add('collected-dot');
      dot.dataset.isBase = "true";
      dot.dataset.hasMultiplied = "false"; // for mobile base one-time rule
      dot.dataset.spawnToggle = (dotCreateCounter++ % 2 === 0) ? "true" : "false"; // alternate
      let colorCls = '';
      for (const cn of buttonElement.classList) {
        if (cn.startsWith('highlight-')) { colorCls = cn; break; }
      }
      const color = highlightColors[colorCls];
      dot.style.backgroundColor = color;
      dot.dataset.color = color;

      const size = 16;
      const rx = Math.random() * (window.innerWidth - size);
      const ry = Math.random() * (window.innerHeight - size);
      dot.style.left = '0px';
      dot.style.top  = '0px';
      dot.style.transform = `translate(${rx}px, ${ry}px)`;
      c.appendChild(dot);

      if (clickedContentIds.size === totalHighlights) startDots();
    }

    // --- dots logic ---
    let running = false;
    let dots = [];
    let mouseX = window.innerWidth/2, mouseY = window.innerHeight/2;

    const R = 260, R2 = R*R;
    const STRENGTH = 4200;
    const FRICTION = 0.92;
    const MAX_SPEED = 28;
    const BOUNCE_COOLDOWN = 120;
    const DOT_SIZE = 16;

    // mobile tilt "gravity"
    let gx=0, gy=0, tiltEnabled=false;

    // mouse sampling (desktop)
    let pendingMouse = null;
    if (!isMobile) window.addEventListener('mousemove', e => { pendingMouse = e; }, {passive:true});

    function startDots() {
      if (running) return;
      const els = Array.from(document.querySelectorAll('.collected-dot'));
      dots = els.map(el => {
        const r = el.getBoundingClientRect();
        el.style.position = 'fixed';
        el.style.willChange = 'transform';
        return {
          el,
          x: r.left, y: r.top, w: r.width||DOT_SIZE, h: r.height||DOT_SIZE,
          vx: (Math.random()*2-1)*2, vy: (Math.random()*2-1)*2,
          lastBounceAt: 0,
          isBase: el.dataset.isBase === "true",
          hasMultiplied: el.dataset.hasMultiplied === "true",
          color: el.dataset.color,
          spawnToggle: el.dataset.spawnToggle === "true" // only these are allowed to spawn
        };
      });

      if (isMobile) setupMotionPermission();
      running = true;
      requestAnimationFrame(loop);
    }

    function setupMotionPermission() {
      const btn = document.getElementById('motion-permission');
      const needPermission = typeof DeviceOrientationEvent !== 'undefined' &&
                             typeof DeviceOrientationEvent.requestPermission === 'function';
      btn.style.display = 'inline-block';
      btn.addEventListener('click', async () => {
        try {
          if (needPermission) {
            const res = await DeviceOrientationEvent.requestPermission();
            if (res !== 'granted') { alert('Motion access denied'); return; }
          }
          enableTilt(); btn.style.display = 'none';
        } catch { enableTilt(); btn.style.display = 'none'; }
      }, { once: true });
    }

    function enableTilt() {
      tiltEnabled = true;
      window.addEventListener('deviceorientation', (e) => {
        const gamma = (e.gamma || 0), beta = (e.beta || 0);
        const scale = 0.02;
        gx = Math.max(-0.6, Math.min(0.6, gamma * scale));
        gy = Math.max(-0.6, Math.min(0.6, beta  * scale));
      }, { passive: true });
    }

    function colorCount(color) {
      let count = 0;
      for (const d of dots) if (d.color === color) count++;
      return count;
    }

    function spawnAllowedForDot(d, mobileCloneOnce=false) {
      // enforce total and per-color caps
      if (dots.length >= TOTAL_CAP) return false;
      if (colorCount(d.color) >= perColorCap) return false;

      // "every alternate dot spawns": must be a spawn-enabled dot
      if (!d.spawnToggle) return false;

      // mobile: base dots can spawn only once (and only if they are spawn-enabled)
      if (isMobile && d.isBase && d.hasMultiplied) return false;

      // on mobile, clones never spawn again; they have spawnToggle set by creation rule below
      return true;
    }

    function spawnCloneFrom(d, mobileCloneOnce=false) {
      if (!spawnAllowedForDot(d, mobileCloneOnce)) return;

      const el = d.el.cloneNode(true);
      const clone = {
        el,
        x: d.x, y: d.y, w: d.w, h: d.h,
        vx: -d.vx + (Math.random()*4 - 2),
        vy: -d.vy + (Math.random()*4 - 2),
        lastBounceAt: 0,
        isBase: false,
        hasMultiplied: mobileCloneOnce, // on mobile, clones considered "already multiplied"
        color: d.color,
        // assign alternating spawn permission by global counter
        spawnToggle: (dotCreateCounter++ % 2 === 0)
      };
      el.style.position = 'fixed';
      el.style.transform = `translate(${clone.x}px, ${clone.y}px)`;
      el.dataset.color = d.color;
      el.dataset.spawnToggle = clone.spawnToggle ? "true" : "false";
      document.getElementById('random-dots-container').appendChild(el);
      dots.push(clone);

      // mark base dot as used once on mobile
      if (isMobile && d.isBase && !d.hasMultiplied) d.hasMultiplied = true;
    }

    function loop(now) {
      if (!running) return;

      if (!isMobile && pendingMouse) { mouseX = pendingMouse.clientX; mouseY = pendingMouse.clientY; pendingMouse = null; }

      const W = window.innerWidth, H = window.innerHeight;
      for (const d of dots) {
        // forces
        if (!isMobile) {
          // desktop "allergic to cursor"
          const cx = d.x + d.w/2, cy = d.y + d.h/2;
          const dx = cx - mouseX, dy = cy - mouseY;
          const dist2 = dx*dx + dy*dy;
          if (dist2 < R2 && dist2 > 1e-6) {
            const dist = Math.sqrt(dist2);
            const force = STRENGTH * (1 - dist / R) / (dist + 1e-6);
            d.vx += (dx / dist) * force * 0.016;
            d.vy += (dy / dist) * force * 0.016;
          }
        } else if (tiltEnabled) {
          // mobile tilt gravity
          d.vx += gx; d.vy += gy;
        }

        // damping & clamp
        d.vx *= FRICTION; d.vy *= FRICTION;
        const sp = Math.hypot(d.vx, d.vy);
        if (sp > MAX_SPEED) { d.vx = d.vx / sp * MAX_SPEED; d.vy = d.vy / sp * MAX_SPEED; }

        // integrate
        d.x += d.vx; d.y += d.vy;

        // bounce
        let collided = false;
        if (d.x <= 0)            { d.x = 0;       d.vx = Math.abs(d.vx)||1;  collided = true; }
        else if (d.x + d.w >= W) { d.x = W-d.w;   d.vx = -Math.abs(d.vx)||-1; collided = true; }
        if (d.y <= 0)            { d.y = 0;       d.vy = Math.abs(d.vy)||1;  collided = true; }
        else if (d.y + d.h >= H) { d.y = H-d.h;   d.vy = -Math.abs(d.vy)||-1; collided = true; }

        if (collided && (now - d.lastBounceAt > BOUNCE_COOLDOWN)) {
          d.lastBounceAt = now;
          d.x = Math.min(Math.max(d.x, 1), W - d.w - 1);
          d.y = Math.min(Math.max(d.y, 1), H - d.h - 1);

          if (isMobile) {
            // mobile: only base dots spawn once (and only if they are "spawn-enabled")
            if (d.isBase && !d.hasMultiplied && d.spawnToggle) {
              spawnCloneFrom(d, true);
            }
          } else {
            // desktop: only spawn-enabled dots spawn every time they bounce
            if (d.spawnToggle) spawnCloneFrom(d, false);
          }
        }

        // render
        d.el.style.transform = `translate(${d.x}px, ${d.y}px)`;
      }
      requestAnimationFrame(loop);
    }

    // --- theme toggle ---
    const themeToggle = document.getElementById('theme-toggle');
    const body = document.body;
    function setTheme(theme) {
      if (theme === 'dark') { body.classList.add('dark-mode'); localStorage.setItem('theme','dark'); themeToggle.textContent='☀'; }
      else { body.classList.remove('dark-mode'); localStorage.setItem('theme','light'); themeToggle.textContent='⏾'; }
    }
    window.addEventListener('DOMContentLoaded',()=>{setTheme(localStorage.getItem('theme')||'light');});
    themeToggle.addEventListener('click',()=>{setTheme(body.classList.contains('dark-mode')?'light':'dark');});

    // --- font size controls ---
    const fontDecreaseBtn=document.getElementById('font-decrease');
    const fontIncreaseBtn=document.getElementById('font-increase');
    const fontSizes=['text-small','text-normal','text-large'];
    let currentFontSizeIndex=1;
    function applyFontSize(i){fontSizes.forEach(c=>body.classList.remove(c));body.classList.add(fontSizes[i]);localStorage.setItem('fontSize',fontSizes[i]);currentFontSizeIndex=i;}
    window.addEventListener('DOMContentLoaded',()=>{const s=localStorage.getItem('fontSize');if(s&&fontSizes.includes(s))applyFontSize(fontSizes.indexOf(s));else applyFontSize(currentFontSizeIndex);});
    fontDecreaseBtn.addEventListener('click',()=>{if(currentFontSizeIndex>0)applyFontSize(currentFontSizeIndex-1);});
    fontIncreaseBtn.addEventListener('click',()=>{if(currentFontSizeIndex<fontSizes.length-1)applyFontSize(currentFontSizeIndex+1);});
  </script>
</body>
</html>
