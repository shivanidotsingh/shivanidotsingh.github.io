<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>process artefacts</title>
<meta name="description" content="process artefacts" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>*</text></svg>">

<style>
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: #fff;
    color: #000;
    font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
    overflow: hidden; /* no scroll */
  }

  .wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
  header { padding: 8px 12px; color: #555; border-bottom: 1px solid #e5e5e5; }
  header .sub { color: #666; font-size: 13px; }

  .stage {
    position: relative;
    overflow: hidden;
    background-image: var(--grid-img);
    background-size: var(--grid-size) var(--grid-size);
    background-repeat: repeat;
  }

  /* grid */
  :root{
    --grid-size: 16px;
    --grid-img: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'>\
<rect width='16' height='16' fill='white'/>\
<path d='M16 0H0V16' fill='none' stroke='%23e9e9e9' stroke-width='1' shape-rendering='crispEdges'/>\
</svg>");
  }

  #canvas { position: relative; width: 100%; height: 100%; }

  .tile {
    position: absolute;
    width: 120px;   /* thumb size */
    background: #fff;
  }
  .tile img { display: block; width: 100%; height: auto; outline: none; }

.focus{
  position:absolute;
  inset: 0;
  margin: auto;
  width: 720px;
  max-width: calc(100vw - 40px);
  max-height: calc(100vh - 90px);
  background: transparent;   /* ← let the grid show through */
}

.focus img{
  display:block;
  width:100%;
  height:100%;
  object-fit:contain;
  background: transparent;    /* ← no white panel */
  outline:none;
}

</style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="sub">behind the scenes of collaboration, and other cuttings from the work desk.</div>
    </header>

    <main class="stage" id="stage">
      <div id="canvas">
        <figure class="focus" id="focusCard"><img id="focusImg" alt=""></figure>
        <!-- thumbnails injected here -->
      </div>
    </main>
  </div>

  <script>
  const IMAGES = [
    "images/process/ADT vision.png",
    "images/process/Concentric.png",
    "images/process/BMC - design.png",
    "images/process/criteriaforintake.png",
    "images/process/CRM.png",
    "images/process/gaps.png",
    "images/process/ladder.jpg",
    "images/process/ideally.jpg",
    "images/process/curriculum.png",
    "images/process/Datapoints.png",
    "images/process/GNC learning.png",
    "images/process/humaneval.png",
    "images/process/knowledge sharing.png",
    "images/process/Laddering Data.jpg",
    "images/process/manual.png",
    "images/process/medium is msg.png",
    "images/process/Name Parameters.png",
    "images/process/naming systems.png",
    "images/process/ORG.png",
    "images/process/ourresources.png",
    "images/process/opp.png",
    "images/process/Persona.jpg",
    "images/process/playground UI.png",
    "images/process/Product Partnerships Data Knowledge.png",
    "images/process/Reach.png",
    "images/process/Reachout if.png",
    "images/process/Rules.png",
    "images/process/scales of a problem.png",
    "images/process/signals.png",
    "images/process/singlesource of truth.png",
    "images/process/dreaming sensing.png",
    "images/process/timeline.png",
    "images/process/types of slides.png",
    "images/process/vendorgrid.png",
    "images/process/whatwedonose.png",
    "images/process/XCapit.png",
    "images/process/x.png"
  ];

  const stage  = document.getElementById('stage');
  const canvas = document.getElementById('canvas');
  const focusImg = document.getElementById('focusImg');

  // tweakables
  const THUMB_W = 120;     // thumbnail width
  const GAP = 8;           // min spacing between thumbs
  const EDGE_PAD_TL = 10;  // top/left pad (keep a little breathing room)
  const EDGE_PAD_RB = 16;  // right/bottom pad (extra to avoid bleed)

  let metas = [];
  let current = -1;

  // load natural sizes
  Promise.all(IMAGES.map(loadMeta)).then(_metas=>{
    metas = _metas;
    placeThumbs();                         // scatter within viewport only
    setFocus(randInt(0, IMAGES.length-1)); // start on a random one
    window.addEventListener('resize', ()=>{ placeThumbs(); setFocus(current); });
  });

  function loadMeta(src){
    return new Promise(res=>{
      const img=new Image();
      img.onload=()=>res({src, w: img.naturalWidth||1000, h: img.naturalHeight||1000, a:(img.naturalHeight||1000)/(img.naturalWidth||1000)});
      img.onerror=()=>res({src, w:1000, h:1000, a:1});
      img.src=encodeURI(src);
    });
  }

  function placeThumbs(){
    // clear thumbnails (keep focus card)
    [...canvas.querySelectorAll('.tile')].forEach(n=>n.remove());

    const W = stage.clientWidth;
    const H = stage.clientHeight;

    // estimate focus frame bbox (to keep clear).
    // tighter VERTICAL padding so thumbs can sit closer top/bottom of big image.
    const focusW = Math.min(720, W - 40);
    const focusH = Math.min(H - 90, focusW * 0.75); // rough (landscape-biased)
    const fx = (W - focusW)/2, fy = (H - focusH)/2;

    const HOLE_PAD_X = 60;  // horizontal keep-out
    const HOLE_PAD_Y = 16;  // vertical keep-out (smaller → closer to image)
    const hole = {
      x: fx - HOLE_PAD_X,
      y: fy - HOLE_PAD_Y,
      w: focusW + HOLE_PAD_X*2,
      h: focusH + HOLE_PAD_Y*2
    };

    const placed = [];
    metas.forEach((m, i) => {
      const th = Math.round(THUMB_W * (m.a || 1));

      let tries = 0, ok = false, x = 0, y = 0;
      while (!ok && tries < 500){
        // clamp ranges so we NEVER bleed the right/bottom
        x = randInt(EDGE_PAD_TL, Math.max(EDGE_PAD_TL, W - THUMB_W - EDGE_PAD_RB));
        y = randInt(EDGE_PAD_TL, Math.max(EDGE_PAD_TL, H - th      - EDGE_PAD_RB));

        const cand = { x, y, w: THUMB_W, h: th };

        ok = !rectsOverlap(cand, hole, 6) && // slight overlap allowed only when squares get focused later; we don't reflow
             placed.every(p => !rectsOverlap(cand, p, GAP));
        tries++;
      }

      placed.push({ x, y, w: THUMB_W, h: th });

      const fig = document.createElement('figure');
      fig.className = 'tile';
      fig.style.left = x + 'px';
      fig.style.top  = y + 'px';
      fig.style.width= THUMB_W + 'px';
      fig.dataset.index = i;

      const im = document.createElement('img');
      im.alt = `img ${i+1}`;
      im.src = encodeURI(m.src);
      fig.appendChild(im);

      fig.addEventListener('click', ()=> setFocus(i));
      canvas.appendChild(fig);
    });
  }

  function setFocus(i){
    current = ((i % metas.length) + metas.length) % metas.length;
    const m = metas[current];
    focusImg.src = encodeURI(m.src);
    focusImg.alt = `image ${current+1}`;
    // Note: we do NOT reflow thumbnails on focus change
    // (okay if a square image overlaps a bit, per your note).
  }

  // helpers
  function rectsOverlap(a, b, gap){
    return !(a.x + a.w + gap <= b.x ||
             b.x + b.w + gap <= a.x ||
             a.y + a.h + gap <= b.y ||
             b.y + b.h + gap <= a.y);
  }
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; }
  </script>
</body>
</html>
