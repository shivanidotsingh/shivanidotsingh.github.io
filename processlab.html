<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>making of the sausage</title>
<meta name="description" content="artefacts from work - out of context" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>✧</text></svg>">

<style>
  :root{
    --bg:#fff; --fg:#111;
    --page-pad: 24px;       /* page padding */
    --min-w: 260px;         /* min image width */
    --max-w: 560px;         /* max image width */
    --margin: 18px;         /* keep off the edges */
    --tilt: 4deg;           /* max random rotation (±) */
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    -webkit-text-size-adjust: 100%;
  }

  /* Desktop-only wrapper */
  .wrap {
    display: grid;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }

  header {
    padding: 14px max(var(--page-pad), env(safe-area-inset-left)) 6px max(var(--page-pad), env(safe-area-inset-right));
    color: #777; letter-spacing: .25px;
  }

  /* Scrollable stage */
  .stage {
    position: relative;
    overflow: auto;
    padding-inline: var(--page-pad);
  }

  /* Giant absolute-positioned canvas we scatter onto */
  #canvas {
    position: relative;
    width: 100%;
    /* height is set by JS based on count & viewport */
  }

  /* Each figure is absolutely positioned */
  .tile {
    position: absolute;
    margin: 0;
    user-select: none;
    -webkit-user-drag: none;
    touch-action: none;
    transform-origin: center;
  }

  /* Clean images, no borders/shadows/rounded */
  .tile img {
    display: block;
    width: 100%;
    height: auto;
    pointer-events: none;
    background: #fff; /* in case of transparent PNGs */
  }

  /* Mobile/tablet: show only the banner, hide desktop content */
  .mobile-only {
    display: none;
    position: fixed;
    inset: 0;
    place-items: center;
    text-align: center;
    padding: 24px;
    background: #fff;
    color: #111;
  }
  @media (hover: none) and (pointer: coarse) {
    .wrap { display: none; }
    .mobile-only { display: grid; }
  }
</style>
</head>

<body>
  <!-- Desktop content -->
  <div class="wrap">
    <header>screenshots from the desktop, out of context</header>
    <main class="stage" id="stage">
      <div id="canvas" aria-label="Random scatter of artefacts"></div>
    </main>
  </div>

  <!-- Mobile/tablet message -->
  <div class="mobile-only">view on desktop</div>

  <script>
    // Your images
    const IMAGES = [
      "images/process/ADT vision.png",
      "images/process/Concentric.png",
      "images/process/criteriaforintake.png",
      "images/process/CRM.png",
      "images/process/cryptotransfer.png",
      "images/process/curriculum.png",
      "images/process/Datapoints.png",
      "images/process/GNC learning.png",
      "images/process/humaneval.png",
      "images/process/knowledge sharing.png",
      "images/process/Laddering Data.jpg",
      "images/process/manual.png",
      "images/process/medium is msg.png",
      "images/process/Name Parameters.png",
      "images/process/naming systems.png",
      "images/process/ORG.png",
      "images/process/ourresources.png",
      "images/process/opp.png",
      "images/process/Persona.jpg",
      "images/process/ideally.jpg",
      "images/process/playground UI.png",
      "images/process/Product Partnerships Data Knowledge.png",
      "images/process/Reach.png",
      "images/process/Reachout if.png",
      "images/process/Rules.png",
      "images/process/scales of a problem.png",
      "images/process/timeline.png",
      "images/process/types of slides.png",
      "images/process/vendorgrid.png",
      "images/process/whatwedonose.png",
      "images/process/gov.jpg",
      "images/process/XCapit.png"
    ];

    // Skip building on touch (mobile banner shows instead)
    const isTouch = matchMedia("(hover: none) and (pointer: coarse)").matches;
    if (!isTouch) {
      const stage = document.getElementById('stage');
      const canvas = document.getElementById('canvas');

      // CSS vars
      const css = getComputedStyle(document.documentElement);
      const MIN_W = parseInt(css.getPropertyValue('--min-w')) || 260;
      const MAX_W = parseInt(css.getPropertyValue('--max-w')) || 560;
      const MARGIN = parseInt(css.getPropertyValue('--margin')) || 18;
      const TILT_DEG = parseFloat(css.getPropertyValue('--tilt')) || 4;

      // Helpers
      const rand = (a, b) => Math.random() * (b - a) + a;
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      function layout() {
        // Clear any previous content
        canvas.innerHTML = "";

        // Determine canvas height based on count & viewport:
        // ~ 5–7 images per screen height. Make 4+ screens tall minimum.
        const H = stage.clientHeight || window.innerHeight;
        const screens = Math.max(4, Math.ceil(IMAGES.length / 6));
        const canvasH = Math.round(screens * H);
        canvas.style.height = canvasH + "px";

        const W = stage.clientWidth;

        // Place images
        const placed = []; // keep rough positions to avoid extreme overlap
        IMAGES.forEach((src, i) => {
          const fig = document.createElement('figure');
          fig.className = 'tile';
          fig.dataset.i = i;

          // random width in range (but don’t exceed viewport)
          const maxAllowed = Math.min(MAX_W, Math.max(MIN_W, W - MARGIN * 2));
          const w = Math.round(rand(MIN_W, maxAllowed));
          fig.style.width = w + "px";

          // tiny random rotation
          const rot = rand(-TILT_DEG, TILT_DEG);
          fig.style.transform = `rotate(${rot}deg)`;

          const img = document.createElement('img');
          img.loading = 'lazy';
          img.decoding = 'async';
          img.alt = `artefact ${i + 1}`;
          img.src = encodeURI(src);
          fig.appendChild(img);

          // choose a random position; retry a few times to avoid heavy overlap
          let x = 0, y = 0, tries = 0;
          do {
            x = Math.round(rand(MARGIN, Math.max(MARGIN, W - w - MARGIN)));
            // height is unknown until load; approximate using width/aspect guess ~16:9..1:1
            const approxH = w * rand(0.7, 1.1);
            y = Math.round(rand(MARGIN, Math.max(MARGIN, canvasH - approxH - MARGIN)));
            tries++;
          } while (tooClose(x, y, w, 120) && tries < 12);

          fig.style.left = x + "px";
          fig.style.top  = y + "px";

          canvas.appendChild(fig);
          placed.push({ x, y, w });
        });

        function tooClose(x, y, w, minDist) {
          // very loose proximity check so items aren't stacked on exact same spot
          for (const p of placed) {
            const dx = (p.x + p.w/2) - (x + w/2);
            const dy = (p.y) - (y);
            const d2 = dx*dx + dy*dy;
            if (d2 < (minDist*minDist)) return true;
          }
          return false;
        }
      }

      // initial layout
      layout();

      // Relayout on resize (recomputes positions for the new width/height)
      let rid = null;
      window.addEventListener('resize', () => {
        cancelAnimationFrame(rid);
        rid = requestAnimationFrame(layout);
      });
    }
  </script>
</body>
</html>
