<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>making of the sausage</title>
  <meta name="description" content="artefacts from work - out of context." />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>✧</text></svg>">
  <style>
    :root { --ring: #fff; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: #000; color: #111; font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    }

    /* full-viewport stage */
    #stage { position: fixed; inset: 0; overflow: hidden; }
    .tile { position: absolute; user-select: none; -webkit-user-drag: none; touch-action: none; }
    .tile img { display: block; width: 100%; height: auto; pointer-events: none; }

    /* hand cursor */
    .tile { cursor: grab; cursor: -webkit-grab; }
    .tile.dragging { cursor: grabbing; cursor: -webkit-grabbing; }
    
  </style>
</head>
<body>
  <div id="stage" aria-label="Draggable artefacts"></div>
  
  <script>
    const IMAGES = [
  "images/process/ADT vision.png",
  "images/process/Concentric.png",
  "images/process/criteriaforintake.png",
  "images/process/CRM.png",
  "images/process/cryptotransfer.png",
  "images/process/curriculum.png",
  "images/process/Datapoints.png",
  "images/process/GNC learning.png",
  "images/process/humaneval.png",
  "images/process/knowledge sharing.png",
  "images/process/Laddering Data.jpg",
  "images/process/manual.png",
  "images/process/medium is msg.png",
  "images/process/Name Parameters.png",
  "images/process/naming systems.png",
  "images/process/ORG.png",
  "images/process/ourresources.png",
  "images/process/Persona.jpg",
  "images/process/playground UI.png",
  "images/process/Product Partnerships Data Knowledge.png",
  "images/process/Reach.png",
  "images/process/Rules.png",
  "images/process/scales of a problem.png",
  "images/process/timeline.png",
  "images/process/types of slides.png",
  "images/process/vendorgrid.png",
  "images/process/whatwedonose.png",
  "images/process/why-how.png",
  "images/process/XCapit.png",
];

    // ---- util helpers ----
    const $ = sel => document.querySelector(sel);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => Math.random() * (b - a) + a;

    const stage = $('#stage');
let zCounter = 1000; // global topmost z-index counter

    function makeTile(src, i) {
      const el = document.createElement('figure');
      el.className = 'tile'; el.dataset.i = i;
      // random width (no card chrome)
      const w = Math.round(rand(300, 600));
      el.style.width = w + 'px';
      // random position within viewport
      const maxX = window.innerWidth - w - 20;
      const maxY = window.innerHeight - 200; // leave a bit of space near bottom
      const x = Math.max(10, Math.round(rand(10, Math.max(20, maxX))));
      const y = Math.max(10, Math.round(rand(10, Math.max(20, maxY))));
      el.style.left = x + 'px';
      el.style.top  = y + 'px';

      const img = document.createElement('img');
      img.loading = 'lazy'; img.decoding = 'async';
      img.alt = `artefact ${i+1}`;
      
      img.onload = () => {
  const isPortrait = img.naturalHeight > img.naturalWidth;

  // portraits: one consistent width (no variation), but never upscale beyond natural
  const PORTRAIT_WIDTH = 300; // ← set your fixed width
  if (isPortrait) {
    const w = Math.min(PORTRAIT_WIDTH, img.naturalWidth);
    el.style.width = w + 'px';
  } else {
    // landscapes: keep your random width but enforce a minimum
    const MIN_LANDSCAPE = 420; // tweak if you like
    const current = el.clientWidth; // whatever rand(...) set
    el.style.width = Math.max(current, MIN_LANDSCAPE) + 'px';

  }

  // keep inside viewport after width update
  el.style.left = clamp(parseFloat(el.style.left)||0, 0, window.innerWidth - el.clientWidth) + 'px';
  el.style.top  = clamp(parseFloat(el.style.top)||0,  0, window.innerHeight - el.clientHeight) + 'px';
};

      img.src = encodeURI(src);
      el.appendChild(img);

      enableDrag(el);
      return el;
    }

    // ---- drag (pointer events), minimal ----
    function enableDrag(el) {
      let id = null, sx=0, sy=0, ox=0, oy=0;
      
      el.addEventListener('pointerdown', (e) => {
        el.setPointerCapture(e.pointerId);
        id = e.pointerId; sx = e.clientX; sy = e.clientY;
        ox = parseFloat(el.style.left)||0; oy = parseFloat(el.style.top)||0;
        el.style.zIndex = (++zCounter).toString();
        el.classList.add('dragging');
              });

      el.addEventListener('pointermove', (e) => {
        if (id !== e.pointerId) return;
        const nx = clamp(ox + (e.clientX - sx), 0, window.innerWidth - el.clientWidth);
        const ny = clamp(oy + (e.clientY - sy), 0, window.innerHeight - el.clientHeight);
        el.style.left = nx + 'px';
        el.style.top  = ny + 'px';
      });

      const end = () => { id = null; el.classList.remove('dragging'); };
      el.addEventListener('pointerup', end);
      el.addEventListener('pointercancel', end);
      el.addEventListener('lostpointercapture', end);
    }

    
    // ---- build ----
    IMAGES.forEach((src, i) => stage.appendChild(makeTile(src, i)));

    // keep tiles inside viewport if resized
    window.addEventListener('resize', () => {
      document.querySelectorAll('.tile').forEach(el => {
        el.style.left = clamp(parseFloat(el.style.left)||0, 0, window.innerWidth - el.clientWidth) + 'px';
        el.style.top  = clamp(parseFloat(el.style.top)||0,  0, window.innerHeight - el.clientHeight) + 'px';
      });
    });
  </script>
</body>
</html>
