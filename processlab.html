<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>making of the sausage</title>
  <meta name="description" content="artefacts from work - out of context." />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>✧</text></svg>">
  <style>
    :root{
      --gap: 28px;    /* space between tiles */
      --pad: 120px;   /* outer padding around the whole field */
      --colw: 420px;  /* landscape width */
      --port: 300px;  /* portrait width cap */
      --cols-each-side: 12; /* columns to the left and to the right of center */
      --canvas-w: 14000px;  /* generous size; JS will resize down after layout */
      --canvas-h: 10000px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #fff; font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }

    /* Two-dimensional scroll */
    #viewport { position: fixed; inset: 0; overflow: auto; }
    #canvas   { position: relative; width: var(--canvas-w); height: var(--canvas-h); }

    .tile { position: absolute; user-select: none; -webkit-user-drag: none; touch-action: none; }
    .tile img { display: block; width: 100%; height: auto; }
  </style>
</head>
<body>
  <div id="viewport" aria-label="2D Masonry">
    <div id="canvas"></div>
  </div>

  <script>
    const IMAGES = [
      "images/process/ADT vision.png",
      "images/process/Concentric.png",
      "images/process/criteriaforintake.png",
      "images/process/CRM.png",
      "images/process/cryptotransfer.png",
      "images/process/curriculum.png",
      "images/process/Datapoints.png",
      "images/process/GNC learning.png",
      "images/process/humaneval.png",
      "images/process/knowledge sharing.png",
      "images/process/Laddering Data.jpg",
      "images/process/manual.png",
      "images/process/medium is msg.png",
      "images/process/Name Parameters.png",
      "images/process/naming systems.png",
      "images/process/ORG.png",
      "images/process/ourresources.png",
      "images/process/opp.png",
      "images/process/Persona.jpg",
      "images/process/playground UI.png",
      "images/process/Product Partnerships Data Knowledge.png",
      "images/process/Reach.png",
      "images/process/Reachout if.png",
      "images/process/Rules.png",
      "images/process/scales of a problem.png",
      "images/process/timeline.png",
      "images/process/types of slides.png",
      "images/process/vendorgrid.png",
      "images/process/whatwedonose.png",
      "images/process/why-how.png",
      "images/process/XCapit.png"
    ];

    // --- helpers ---
    const $ = sel => document.querySelector(sel);
    const encodeSrc = s => encodeURI(s);

    const viewport = $('#viewport');
    const canvas   = $('#canvas');

    const GAP  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'))  || 28;
    const PAD  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pad'))  || 120;
    const COLW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--colw')) || 420;
    const PORT = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--port')) || 300;
    const COLS_EACH_SIDE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols-each-side')) || 12;

    // preload to know natural sizes
    function preload(src){
      return new Promise(res=>{
        const img = new Image();
        img.decoding = 'async';
        img.onload = ()=> res({src, w: img.naturalWidth, h: img.naturalHeight});
        img.onerror = ()=> res(null);
        img.src = encodeSrc(src);
      });
    }

    // 2D masonry from center:
    // - columns run from negative to positive (left/right of center)
    // - each column has two stacks: up (grows upward) and down (grows downward)
    async function init(){
      const meta = await Promise.all(IMAGES.map(preload));
      const items = meta.filter(Boolean);
      if(!items.length) return;

      const totalCols = COLS_EACH_SIDE * 2 + 1; // include the center column
      const centerX   = Math.max(canvas.clientWidth, 6000) / 2; // rough center
      const centerY   = Math.max(canvas.clientHeight, 4000) / 2;

      // precompute column x positions around center
      const xs = [];
      for(let i = -COLS_EACH_SIDE; i <= COLS_EACH_SIDE; i++){
        const colIndexFromLeft = i + COLS_EACH_SIDE; // 0..N
        const x = centerX - (COLS_EACH_SIDE * (COLW + GAP)) + colIndexFromLeft * (COLW + GAP);
        xs.push({i, x});
      }

      // For each column, maintain downward and upward stack heights
      const stacks = xs.map(()=>({ down: 0, up: 0 })); // values measured from centerY
      let maxRight = -Infinity, minLeft = Infinity, maxBottom = -Infinity, minTop = Infinity;

      // To spread volume, interleave placement order across columns
      // Zig-zag through columns from center outwards
      const columnOrder = [];
      for(let d=0; d<=COLS_EACH_SIDE; d++){
        if(d===0) columnOrder.push(0);
        else { columnOrder.push(-d, d); }
      }

      // iterate items and place each in the globally "shortest" stack (among all columns up+down)
      items.forEach((it, idx)=>{
        const isPortrait = it.h > it.w;
        const targetW = isPortrait ? Math.min(PORT, COLW) : COLW;
        const scale   = targetW / it.w;
        const targetH = Math.round(it.h * scale);

        // find best spot: look at all columns' up & down stack totals (absolute height)
        let best = { colIdx: 0, dir: 'down', height: Infinity };
        for(let c=0; c<stacks.length; c++){
          const s = stacks[c];
          const dHeight = s.down;             // below center
          const uHeight = s.up;               // above center (positive value, we’ll subtract)
          if(dHeight < best.height){ best = {colIdx:c, dir:'down', height:dHeight}; }
          if(uHeight < best.height){ best = {colIdx:c, dir:'up', height:uHeight}; }
        }

        const col = best.colIdx;
        const x = xs[col].x;
        let y;

        if(best.dir === 'down'){
          y = centerY + best.height + (best.height ? GAP : 0);   // space between
          stacks[col].down += (best.height ? GAP : 0) + targetH;
          maxBottom = Math.max(maxBottom, y + targetH);
        }else{
          // place upward (y decreases)
          y = centerY - best.height - (best.height ? GAP : 0) - targetH;
          stacks[col].up += (best.height ? GAP : 0) + targetH;
          minTop = Math.min(minTop, y);
        }

        // create node
        const fig = document.createElement('figure');
        fig.className = 'tile';
        fig.style.width = targetW + 'px';
        fig.style.left  = x + 'px';
        fig.style.top   = y + 'px';

        const image = document.createElement('img');
        image.alt = `artefact ${idx+1}`;
        image.src = encodeSrc(it.src);
        fig.appendChild(image);
        canvas.appendChild(fig);

        minLeft  = Math.min(minLeft, x);
        maxRight = Math.max(maxRight, x + targetW);
      });

      // Grow the canvas to exact bounds + padding
      const leftPad   = Math.max(PAD, centerX - (centerX - minLeft) + PAD);
      const rightPad  = PAD;
      const topPad    = Math.max(PAD, centerY - (centerY - minTop) + PAD);
      const bottomPad = PAD;

      const totalW = (maxRight - minLeft) + leftPad + rightPad;
      const totalH = (maxBottom - minTop) + topPad + bottomPad;

      canvas.style.width  = Math.max(totalW, viewport.clientWidth + PAD*2) + 'px';
      canvas.style.height = Math.max(totalH, viewport.clientHeight + PAD*2) + 'px';

      // Center the viewport on the canvas center so you can move in all directions
      const cx = (canvas.scrollWidth  - viewport.clientWidth ) / 2;
      const cy = (canvas.scrollHeight - viewport.clientHeight) / 2;
      viewport.scrollTo({ left: cx, top: cy });
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
