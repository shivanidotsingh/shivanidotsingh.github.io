<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>cuttings</title>
<meta name="description" content="process lab" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>ð“†‰</text></svg>">

<style>
* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  background: #fff;
  color: #000;
  font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
  overflow: hidden;
}

.wrap { 
  display: grid; 
  grid-template-rows: auto 1fr; 
  height: 100vh; 
}

header { 
  padding: 8px 12px; 
  color: #555; 
  border-bottom: 1px solid #efefef;
  background: #fff;
  position: relative;
  z-index: 100;
}

header .sub { 
  color: #666; 
  font-size: 13px; 
}

.stage {
  position: relative;
  overflow: hidden;
  background:
    repeating-linear-gradient(to right, #efefef 0 1px, transparent 1px 16px),
    repeating-linear-gradient(to bottom, #efefef 0 1px, transparent 1px 16px);
}

#canvas { 
  position: relative; 
  width: 100%; 
  height: 100%; 
}

.image-box {
  position: absolute;
  background: #fff;
}

.image-box img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  filter: brightness(1.1) contrast(0.95); 
}

.thumb {
  cursor: pointer;
}

.main {
  z-index: 10;
}
</style>
</head>

<body>
  <svg style="position: absolute; width: 0; height: 0;">
  <defs>
    <filter id="remove-grey" color-interpolation-filters="sRGB">
      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        0 1 0 0 0
        0 0 1 0 0
        -5 -5 -5 6 0"/>
    </filter>
  </defs>
</svg>
  
<div class="wrap">
  <header>
    <div class="sub">behind the scenes of collaboration, and other cuttings from the work desk.</div>
  </header>

  <main class="stage" id="stage">
    <div id="canvas"></div>
  </main>
</div>

<script>
const IMAGES = [
  "images/process/ADT vision.png",
  "images/process/BMC - design.png",
  "images/process/criteriaforintake.png",
  "images/process/CRM.png",
  "images/process/gaps.png",
  "images/process/ladder.jpg",
  "images/process/ideally.jpg",
  "images/process/curriculum.png",
  "images/process/Datapoints.png",
  "images/process/GNC learning.png",
  "images/process/knowledge sharing.png",
  "images/process/Laddering Data.jpg",
  "images/process/manual.png",
  "images/process/medium is msg.png",
  "images/process/Name Parameters.png",
  "images/process/naming systems.png",
  "images/process/ourresources.png",
  "images/process/opp.png",
  "images/process/Persona.jpg",
  "images/process/playground UI.png",
  "images/process/Product Partnerships Data Knowledge.png",
  "images/process/Reach.png",
  "images/process/Reachout if.png",
  "images/process/Rules.png",
  "images/process/scales of a problem.png",
  "images/process/signals.png",
  "images/process/singlesource of truth.png",
  "images/process/dreaming sensing.png",
  "images/process/timeline.png",
  "images/process/types of slides.png",
  "images/process/vendorgrid.png",
  "images/process/whatwedonose.png",
  "images/process/XCapit.png",
  "images/process/x.png"
];

const G = 16;
const stage = document.getElementById('stage');
const canvas = document.getElementById('canvas');

let mainIndex = 0;

// Cache metadata so we donâ€™t re-wait on every layout/click
const metaCache = new Array(IMAGES.length);   // { src, w, h }
const metaPromises = new Array(IMAGES.length);

let positions = []; // thumb positions (kept during a session; wiped on resize)
let layoutRunId = 0; // cancels old async placements when we relayout

function gridAlign(value) {
  return Math.floor(value / G) * G;
}

function loadMeta(i) {
  if (metaCache[i]) return Promise.resolve(metaCache[i]);
  if (metaPromises[i]) return metaPromises[i];

  metaPromises[i] = new Promise(resolve => {
    const img = new Image();
    img.onload = () => {
      metaCache[i] = { src: IMAGES[i], w: img.naturalWidth || 100, h: img.naturalHeight || 100 };
      resolve(metaCache[i]);
    };
    img.onerror = () => {
      metaCache[i] = { src: IMAGES[i], w: 100, h: 100 };
      resolve(metaCache[i]);
    };
    img.src = IMAGES[i];
  });

  return metaPromises[i];
}

// Creates a positioned image element
function createImageElement(src, pos, isMain, index) {
  const el = document.createElement('div');
  el.className = isMain ? 'image-box main' : 'image-box thumb';
  el.style.left = pos.x + 'px';
  el.style.top = pos.y + 'px';
  el.style.width = pos.w + 'px';
  el.style.height = pos.h + 'px';

  const img = document.createElement('img');
  img.src = src;
  img.decoding = 'async';
  img.loading = isMain ? 'eager' : 'lazy';
  el.appendChild(img);

  if (!isMain) {
    el.addEventListener('click', () => {
  mainIndex = index;
  layoutInitialProgressive(); 
});
  }

  canvas.appendChild(el);
}

function computeMainPos(mainMeta, W, H) {
  const mainAspect = mainMeta.h / mainMeta.w;

  let mainW = gridAlign(W * 0.75);
  let mainH = gridAlign(mainW * mainAspect);

  if (mainH > H * 0.75) {
    mainH = gridAlign(H * 0.75);
    mainW = gridAlign(mainH / mainAspect);
  }

  const mainX = gridAlign((W - mainW) / 2);
  const mainY = gridAlign((H - mainH) / 2);

  return { x: mainX, y: mainY, w: mainW, h: mainH };
}

// Progressive layout: show main as soon as it loads, then place thumbs as each loads
function layoutInitialProgressive() {
  const runId = ++layoutRunId;
  canvas.innerHTML = '';

  const W = stage.clientWidth;
  const H = stage.clientHeight;

  // 1) Load ONLY the selected main image first
  loadMeta(mainIndex).then(mainMeta => {
    if (runId !== layoutRunId) return;

    // Draw main
    const mainPos = computeMainPos(mainMeta, W, H);
    createImageElement(mainMeta.src, mainPos, true, mainIndex);

    // Exclusion zone (same as your original: basically none)
    const pad = 0;
    const exclude = {
      x: mainPos.x - pad,
      y: mainPos.y - pad,
      w: mainPos.w + pad * 2,
      h: mainPos.h + pad * 2
    };

    // 2) Thumbs: place progressively as their metadata becomes available
    const placed = [];

    // If positions already exist (rare here because you wipe on resize/click), reuse them:
    const canReuse = positions.length === IMAGES.length && positions.some(Boolean);

    if (canReuse) {
      // Draw existing thumbs immediately (metas may still load, but browser will fetch images)
      positions.forEach((pos, i) => {
        if (!pos || i === mainIndex) return;
        createImageElement(IMAGES[i], pos, false, i);
        placed.push(pos);
      });
      return;
    }

    // Ensure positions array has correct length
    positions = new Array(IMAGES.length).fill(null);

    // Start loading all thumbs in parallel
    IMAGES.forEach((_, i) => {
      if (i === mainIndex) return;

      loadMeta(i).then(meta => {
        if (runId !== layoutRunId) return;

        const aspect = meta.h / meta.w;
        const baseW = 128;
        let thumbW = gridAlign(baseW);
        let thumbH = gridAlign(thumbW * aspect);

        let attempts = 0;
        let pos = null;

        while (attempts < 1500 && !pos) {
          const x = gridAlign(Math.random() * (W - thumbW - G));
          const y = gridAlign(Math.random() * (H - thumbH - G));

          const box = { x, y, w: thumbW, h: thumbH };

          const overlapsMain = !(
            box.x + box.w <= exclude.x || exclude.x + exclude.w <= box.x ||
            box.y + box.h <= exclude.y || exclude.y + exclude.h <= box.y
          );

          const overlapsThumb = placed.some(p =>
            !(box.x + box.w + G <= p.x || p.x + p.w + G <= box.x ||
              box.y + box.h + G <= p.y || p.y + p.h + G <= box.y)
          );

          if (!overlapsMain && !overlapsThumb && x >= 0 && y >= 0 && x + thumbW <= W && y + thumbH <= H) {
            pos = box;
          }

          attempts++;

          if (attempts % 300 === 0 && thumbW > 64) {
            thumbW = gridAlign(thumbW - G);
            thumbH = gridAlign(thumbW * aspect);
          }
        }

        if (pos) {
          positions[i] = pos;
          placed.push(pos);
          createImageElement(meta.src, pos, false, i);
        }
      });
    });
  });
}

// Initial render
layoutInitialProgressive();

// Reshuffle on resize (your preference)
window.addEventListener('resize', () => {
  positions = [];
  layoutInitialProgressive();
});
</script>
</body>
</html>
