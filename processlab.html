<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>cuttings</title>
<meta name="description" content="process lab" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>ð“†‰</text></svg>">

<style>
* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  background: #fff;
  color: #000;
  font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
  overflow: hidden;
}

.wrap { 
  display: grid; 
  grid-template-rows: auto 1fr; 
  height: 100vh; 
}

header { 
  padding: 8px 12px; 
  color: #555; 
  border-bottom: 1px solid #efefef;
  background: #fff;
  position: relative;
  z-index: 100;
}

header .sub { 
  color: #666; 
  font-size: 13px; 
}

.stage {
  position: relative;
  overflow: hidden;
  background:
    repeating-linear-gradient(to right, #efefef 0 1px, transparent 1px 16px),
    repeating-linear-gradient(to bottom, #efefef 0 1px, transparent 1px 16px);
}

#canvas { 
  position: relative; 
  width: 100%; 
  height: 100%; 
}

.image-box {
  position: absolute;
  background: #fff;
}

.image-box img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  filter: brightness(1.1) contrast(0.95); 
}

.thumb {
  cursor: pointer;
}

.main {
  z-index: 10;
}
</style>
</head>

<body>
  <svg style="position: absolute; width: 0; height: 0;">
  <defs>
    <filter id="remove-grey" color-interpolation-filters="sRGB">
      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        0 1 0 0 0
        0 0 1 0 0
        -5 -5 -5 6 0"/>
    </filter>
  </defs>
</svg>
  
<div class="wrap">
  <header>
    <div class="sub">behind the scenes of collaboration, and other cuttings from the work desk.</div>
  </header>

  <main class="stage" id="stage">
    <div id="canvas"></div>
  </main>
</div>

<script>
const IMAGES = [
  "images/process/ADT vision.png",
  "images/process/BMC - design.png",
  "images/process/criteriaforintake.png",
  "images/process/CRM.png",
  "images/process/gaps.png",
  "images/process/ladder.jpg",
  "images/process/ideally.jpg",
  "images/process/curriculum.png",
  "images/process/Datapoints.png",
  "images/process/GNC learning.png",
  "images/process/knowledge sharing.png",
  "images/process/Laddering Data.jpg",
  "images/process/manual.png",
  "images/process/medium is msg.png",
  "images/process/Name Parameters.png",
  "images/process/naming systems.png",
  "images/process/ourresources.png",
  "images/process/opp.png",
  "images/process/Persona.jpg",
  "images/process/playground UI.png",
  "images/process/Product Partnerships Data Knowledge.png",
  "images/process/Reach.png",
  "images/process/Reachout if.png",
  "images/process/Rules.png",
  "images/process/scales of a problem.png",
  "images/process/signals.png",
  "images/process/singlesource of truth.png",
  "images/process/dreaming sensing.png",
  "images/process/timeline.png",
  "images/process/types of slides.png",
  "images/process/vendorgrid.png",
  "images/process/whatwedonose.png",
  "images/process/XCapit.png",
  "images/process/x.png"
];

const G = 16;
const stage = document.getElementById('stage');
const canvas = document.getElementById('canvas');

let images = [];
let mainIndex = 0;
let positions = []; 
let mainEl = null; 
let thumbEls = [];  

// Load all images and get their natural dimensions
Promise.all(IMAGES.map(src => {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve({ src, w: img.naturalWidth, h: img.naturalHeight });
    img.onerror = () => resolve({ src, w: 100, h: 100 });
    img.src = src;
  });
})).then(loaded => {
  images = loaded;
  layoutInitial();
  window.addEventListener('resize', () => {
    positions = [];
    layoutInitial();
  });
});

function gridAlign(value) {
  return Math.floor(value / G) * G;
}

function layoutInitial() {
  // Clear canvas once (we won't rebuild thumbnails on every click anymore)
  canvas.innerHTML = '';

  const W = stage.clientWidth;
  const H = stage.clientHeight;

  // ---------- 1) Place thumbnails (once, using stored positions) ----------
  if (positions.length === 0) {
    const placed = [];

    images.forEach((img, i) => {
      const aspect = img.h / img.w;
      const baseW = 128;
      let thumbW = gridAlign(baseW);
      let thumbH = gridAlign(thumbW * aspect);

      let attempts = 0;
      let pos = null;

      while (attempts < 1500 && !pos) {
        const x = gridAlign(Math.random() * (W - thumbW - G));
        const y = gridAlign(Math.random() * (H - thumbH - G));
        const box = { x, y, w: thumbW, h: thumbH };

        const overlapsThumb = placed.some(p =>
          !(box.x + box.w + G <= p.x || p.x + p.w + G <= box.x ||
            box.y + box.h + G <= p.y || p.y + p.h + G <= box.y)
        );

        if (!overlapsThumb && x >= 0 && y >= 0 && x + thumbW <= W && y + thumbH <= H) {
          pos = box;
        }

        attempts++;

        if (attempts % 300 === 0 && thumbW > 64) {
          thumbW = gridAlign(thumbW - G);
          thumbH = gridAlign(thumbW * aspect);
        }
      }

      positions[i] = pos; // IMPORTANT: every image gets a thumb position now
      if (pos) placed.push(pos);
    });
  }

  // Draw thumbnails
  thumbEls = [];
  positions.forEach((pos, i) => {
    if (!pos) return;

    const el = document.createElement('div');
    el.className = 'image-box thumb';
    el.style.left = pos.x + 'px';
    el.style.top = pos.y + 'px';
    el.style.width = pos.w + 'px';
    el.style.height = pos.h + 'px';

    const img = document.createElement('img');
    img.src = images[i].src;
    el.appendChild(img);

    el.addEventListener('click', () => {
      mainIndex = i;
      updateMain(); // ONLY update centered viewer
    });

    canvas.appendChild(el);
    thumbEls.push(el);
  });

  // ---------- 2) Create centered main viewer (once) ----------
  mainEl = document.createElement('div');
  mainEl.className = 'image-box main';
  mainEl.style.position = 'absolute';
  canvas.appendChild(mainEl);

  updateMain(); // set initial centered image
}

  function updateMain() {
  const W = stage.clientWidth;
  const H = stage.clientHeight;

  const main = images[mainIndex];
  const mainAspect = main.h / main.w;

  let mainW = gridAlign(W * 0.75);
  let mainH = gridAlign(mainW * mainAspect);

  if (mainH > H * 0.75) {
    mainH = gridAlign(H * 0.75);
    mainW = gridAlign(mainH / mainAspect);
  }

  const mainX = gridAlign((W - mainW) / 2);
  const mainY = gridAlign((H - mainH) / 2);

  mainEl.style.left = mainX + 'px';
  mainEl.style.top = mainY + 'px';
  mainEl.style.width = mainW + 'px';
  mainEl.style.height = mainH + 'px';

  // swap image
  mainEl.innerHTML = '';
  const img = document.createElement('img');
  img.src = main.src;
  mainEl.appendChild(img);
}

function createImageElement(src, pos, isMain, index) {
  const el = document.createElement('div');
  el.className = isMain ? 'image-box main' : 'image-box thumb';
  el.style.left = pos.x + 'px';
  el.style.top = pos.y + 'px';
  el.style.width = pos.w + 'px';
  el.style.height = pos.h + 'px';
  
  const img = document.createElement('img');
  img.src = src;
  el.appendChild(img);
  
  if (!isMain) {
    el.addEventListener('click', () => {
      mainIndex = index;
      layoutInitial();
    });
  }
  
  canvas.appendChild(el);
}

function layout() {
  layoutInitial();
}
</script>
</body>
</html>
