<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>process artefacts</title>
<meta name="description" content="process lab" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>ð“†‰</text></svg>">

<style>
  /* barebones */
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: #fff;
    color: #000;
    font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
    overflow: hidden; /* single-screen composition, no scroll */
  }

  .wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
  header { padding: 8px 12px; color: #555; border-bottom: 1px solid #efefef; }
  header .sub { color: #666; font-size: 13px; }

  :root{
    --grid: 16px;         
    --grid-line: #efefef;  
    --hole-pad-x: 48px;     
    --hole-pad-y: 16px;
  }

  .stage{
    position: relative;
    overflow: hidden;
    background:
      repeating-linear-gradient(to right, var(--grid-line) 0 1px, transparent 1px var(--grid)),
      repeating-linear-gradient(to bottom, var(--grid-line) 0 1px, transparent 1px var(--grid));
    background-position: 0 0;
  }

  #canvas { position: relative; width: 100%; height: 100%; }

  .tile, .focus { position: absolute; background: #fff; }
  .tile img, .focus img { display: block; width: 100%; height: 100%; }
</style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="sub">behind the scenes of collaboration, and other cuttings from the work desk.</div>
    </header>

    <main class="stage" id="stage">
      <div id="canvas">
        <figure class="focus" id="focusCard"><img id="focusImg" alt=""></figure>
        <!-- thumbnails injected below -->
      </div>
    </main>
  </div>

  <script>
    /* === data === */
    const IMAGES = [
      "images/process/ADT vision.png",
      "images/process/BMC - design.png",
      "images/process/criteriaforintake.png",
      "images/process/CRM.png",
      "images/process/gaps.png",
      "images/process/ladder.jpg",
      "images/process/ideally.jpg",
      "images/process/curriculum.png",
      "images/process/Datapoints.png",
      "images/process/GNC learning.png",
      "images/process/humaneval.png",
      "images/process/knowledge sharing.png",
      "images/process/Laddering Data.jpg",
      "images/process/manual.png",
      "images/process/medium is msg.png",
      "images/process/Name Parameters.png",
      "images/process/naming systems.png",
      "images/process/ourresources.png",
      "images/process/opp.png",
      "images/process/Persona.jpg",
      "images/process/playground UI.png",
      "images/process/Product Partnerships Data Knowledge.png",
      "images/process/Reach.png",
      "images/process/Reachout if.png",
      "images/process/Rules.png",
      "images/process/scales of a problem.png",
      "images/process/signals.png",
      "images/process/singlesource of truth.png",
      "images/process/dreaming sensing.png",
      "images/process/timeline.png",
      "images/process/types of slides.png",
      "images/process/vendorgrid.png",
      "images/process/whatwedonose.png",
      "images/process/XCapit.png",
      "images/process/x.png"
    ];

    /* === elements === */
    const stage    = document.getElementById('stage');
    const canvas   = document.getElementById('canvas');
    const focusEl  = document.getElementById('focusCard');
    const focusImg = document.getElementById('focusImg');

    /* === constants / helpers === */
    const GRID = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid')) || 16;
    const EDGE_TL = GRID;        // safe padding left/top
    const EDGE_RB = GRID;        // safe padding right/bottom
    const GAP     = GRID;        // minimum gap between thumbs (1 grid)
    const HOLE_PAD_X = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hole-pad-x')) || 48;
    const HOLE_PAD_Y = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hole-pad-y')) || 16;

    const snap  = v => Math.round(v / GRID) * GRID;
    const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
    const randInt = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;

    // fully snapped fit-box using REAL aspect; returns integers snapped to grid
    function fitSnappedBox(maxW, maxH, aspect){
      let w = snap(maxW);
      let h = snap(Math.max(GRID, w * aspect));
      if (h > maxH){ h = snap(maxH); w = snap(Math.max(GRID, h / aspect)); }
      return { w, h };
    }

    // no-overlap check in px space with a grid-sized gap
    function rectsOverlap(a, b, gap){
      return !(a.x + a.w + gap <= b.x ||
               b.x + b.w + gap <= a.x ||
               a.y + a.h + gap <= b.y ||
               b.y + b.h + gap <= a.y);
    }

    /* === load natural sizes === */
    Promise.all(IMAGES.map(loadMeta)).then(metas=>{
      // build once, keep simple
      build(metas);
      // start on a random focus image
      setFocus(randInt(0, metas.length-1), metas);
      // keep snapping on resize
      window.addEventListener('resize', ()=>{ build(metas); setFocus(current, metas); });
    });

    function loadMeta(src){
      return new Promise(res=>{
        const img = new Image();
        img.onload = ()=> res({ src, a: (img.naturalHeight||1000)/(img.naturalWidth||1000) });
        img.onerror= ()=> res({ src, a: 1 });
        img.src = encodeURI(src);
      });
    }

    let current = -1;

    function setFocus(i, metas){
      current = ((i % metas.length) + metas.length) % metas.length;
      const m = metas[current];
      focusImg.src = encodeURI(m.src);
      focusImg.alt = `image ${current+1}`;
      // place focus box exactly on-grid using the image's REAL aspect
      positionFocusSnapped(m.a);
    }

    function positionFocusSnapped(aspect){
      const W = stage.clientWidth;
      const H = stage.clientHeight;

      const { w: fw, h: fh } = fitSnappedBox(W - snap(40), H - snap(90), aspect);

      let left = snap((W - fw)/2);
      let top  = snap((H - fh)/2);
      left = clamp(left, EDGE_TL, Math.max(EDGE_TL, W - fw - EDGE_RB));
      top  = clamp(top,  EDGE_TL, Math.max(EDGE_TL, H - fh - EDGE_RB));

      focusEl.style.left   = left + 'px';
      focusEl.style.top    = top  + 'px';
      focusEl.style.width  = fw   + 'px';
      focusEl.style.height = fh   + 'px';
    }

    function build(metas){
      // wipe old thumbs
      [...canvas.querySelectorAll('.tile')].forEach(n=>n.remove());

      const W = stage.clientWidth;
      const H = stage.clientHeight;

      // carve a centered keep-out hole (use neutral 16:9 just to reserve space)
      const { w: fw0, h: fh0 } = fitSnappedBox(W - snap(40), H - snap(90), 9/16);
      const fx0 = snap((W - fw0)/2);
      const fy0 = snap((H - fh0)/2);
      const hole = {
        x: snap(fx0 - HOLE_PAD_X),
        y: snap(fy0 - HOLE_PAD_Y),
        w: snap(fw0 + HOLE_PAD_X*2),
        h: snap(fh0 + HOLE_PAD_Y*2)
      };

      // base thumb width as a multiple of grid; will shrink per-thumb if needed to avoid overlaps
      const BASE_TW = snap(128);                 // 8 * 16
      const MIN_TW  = snap(Math.max(80, GRID*4)); // do not go below 5*16 = 80px (or 4*16 on tiny screens)

      const placedRects = [];

      metas.forEach((m, i)=>{
        let TW = BASE_TW;
        let TH = snap(Math.max(GRID, TW * m.a));

        let placed = false;
        let attempts = 0;

        while(!placed && attempts < 1200){
          // random snapped candidate within edges
          let x = clamp(snap(randInt(EDGE_TL, Math.max(EDGE_TL, W - TW - EDGE_RB))), EDGE_TL, W - TW - EDGE_RB);
          let y = clamp(snap(randInt(EDGE_TL, Math.max(EDGE_TL, H - TH - EDGE_RB))), EDGE_TL, H - TH - EDGE_RB);

          const cand = { x, y, w: TW, h: TH };

          const intersectsHole = rectsOverlap(cand, hole, GAP);
          const intersectsAny  = placedRects.some(r => rectsOverlap(cand, r, GAP));

          if (!intersectsHole && !intersectsAny){
            // place it
            placeThumb(i, cand);
            placedRects.push(cand);
            placed = true;
          } else {
            // try another spot; after N tries, shrink by one grid step (keeps on-grid), then continue
            attempts++;
            if (attempts % 180 === 0 && TW > MIN_TW){
              TW = snap(TW - GRID);             // shrink width by 1 grid
              TH = snap(Math.max(GRID, TW * m.a)); // keep aspect exact + snapped
            }
          }
        }
        // if not placed after all attempts, we skip that one (avoids overlap + avoids â€œdisappearing everythingâ€)
      });
    }

    function placeThumb(i, rect){
      const fig = document.createElement('figure');
      fig.className = 'tile';
      fig.style.left   = rect.x + 'px';
      fig.style.top    = rect.y + 'px';
      fig.style.width  = rect.w + 'px';
      fig.style.height = rect.h + 'px';
      fig.dataset.index = i;

      const im = document.createElement('img');
      im.alt = `img ${i+1}`;
      im.src = encodeURI(IMAGES[i]);
      fig.appendChild(im);

      fig.addEventListener('click', ()=> setFocus(i, null)); // metas not needed here; setFocus reads the image again
      canvas.appendChild(fig);
    }
  </script>
</body>
</html>
