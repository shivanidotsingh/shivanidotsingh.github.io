<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>facilitation archives</title>
<meta name="description" content="process artefacts" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>*</text></svg>">

<style>
  /* ====== BAREBONES ====== */
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: #fff;
    color: #000;
    font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
  }

  .wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
  header { padding: 8px 12px; color: #555; }

  /* Scroll area */
  .stage { position: relative; overflow: auto; }
  #canvas  { position: relative; }

  /* Thumbnails (tiny) */
  .tile {
    position: absolute;
    width: 140px;         /* thumb width */
    border: 1px solid #ddd;
    background: #fff;
  }
  .tile img { display: block; width: 100%; height: auto; }

  /* Centered focused image (just the image, no chrome) */
  .focus-layer { position: fixed; inset: 0; pointer-events: none; }
  .focus-card  {
    position: absolute; left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    width: 720px;                     /* big image width */
    max-width: calc(100vw - 32px);
    max-height: 90vh;
    background: #fff;
    pointer-events: auto;             /* allow clicking the image (future) */
  }
  .focus-card img {
    width: 100%; height: 100%; object-fit: contain; background: #fff;
    border: 1px solid #ddd;          /* simple 1px, can remove if you want */
  }

  /* Phones: hard-stop (optional; remove if you want mobile too) */
  .mobile-only { display: none; position: fixed; inset: 0; align-items: center; justify-content: center; background:#fff; }
  @media (max-width: 767px){
    .wrap{ display:none }
    .mobile-only{ display:flex }
  }
</style>
</head>

<body>
  <div class="wrap">
    <header>process cuttings (click a thumbnail)</header>
    <main class="stage" id="stage">
      <div id="canvas" aria-label="scattered thumbnails"></div>

      <!-- centered big image -->
      <div class="focus-layer" id="focusLayer">
        <figure class="focus-card" id="focusCard">
          <img id="focusImg" alt="">
        </figure>
      </div>
    </main>
  </div>

  <div class="mobile-only">view on desktop</div>

  <script>
  /* your images */
  const IMAGES = [
    "images/process/ADT vision.png",
    "images/process/Concentric.png",
    "images/process/BMC - design.png",
    "images/process/criteriaforintake.png",
    "images/process/CRM.png",
    "images/process/gaps.png",
    "images/process/ladder.jpg",
    "images/process/ideally.jpg",
    "images/process/curriculum.png",
    "images/process/Datapoints.png",
    "images/process/GNC learning.png",
    "images/process/humaneval.png",
    "images/process/knowledge sharing.png",
    "images/process/Laddering Data.jpg",
    "images/process/manual.png",
    "images/process/medium is msg.png",
    "images/process/Name Parameters.png",
    "images/process/naming systems.png",
    "images/process/ORG.png",
    "images/process/ourresources.png",
    "images/process/opp.png",
    "images/process/Persona.jpg",
    "images/process/playground UI.png",
    "images/process/Product Partnerships Data Knowledge.png",
    "images/process/Reach.png",
    "images/process/Reachout if.png",
    "images/process/Rules.png",
    "images/process/scales of a problem.png",
    "images/process/signals.png",
    "images/process/singlesource of truth.png",
    "images/process/dreaming sensing.png",
    "images/process/timeline.png",
    "images/process/types of slides.png",
    "images/process/vendorgrid.png",
    "images/process/whatwedonose.png",
    "images/process/XCapit.png",
    "images/process/x.png"
  ];

  const isPhone = matchMedia("(max-width: 767px)").matches;
  if (!isPhone){
    const stage  = document.getElementById('stage');
    const canvas = document.getElementById('canvas');
    const focusImg = document.getElementById('focusImg');

    let metas = [];
    let current = -1;

    // load natural sizes
    Promise.all(IMAGES.map(loadMeta)).then(_metas=>{
      metas = _metas;
      buildScatter();
      centerScroll();
      setFocus(Math.floor(Math.random() * IMAGES.length)); // start on a random one
    });

    function loadMeta(src){
      return new Promise(res=>{
        const img=new Image();
        img.onload=()=>res({src, w: img.naturalWidth||1000, h: img.naturalHeight||1000, a: (img.naturalHeight||1000)/(img.naturalWidth||1000)});
        img.onerror=()=>res({src, w:1000, h:1000, a:1});
        img.src=encodeURI(src);
      });
    }

    function buildScatter(){
      canvas.innerHTML = "";

      const vw = stage.clientWidth;
      const vh = stage.clientHeight;

      // large canvas so thumbs can be placed all around the viewport center
      const CW = Math.max(3200, vw*4);
      const CH = Math.max(2400, vh*4);
      canvas.style.width  = CW + 'px';
      canvas.style.height = CH + 'px';

      const CX = CW/2, CY = CH/2;
      const gap = 10;         // min spacing between thumbs
      const TW  = 140;        // thumbnail width
      const placed = [];

      metas.forEach((m, i)=>{
        const th = Math.round(TW * (m.a || 1));
        let tries=0, ok=false, x=0, y=0;

        // keep a clean hole in the center so the big image sits free
        const hole = Math.min(vw, vh) * 0.7;
        const Rmin = hole * 0.55;
        const Rmax = Math.min(CW, CH) * 0.45;

        while (!ok && tries<500){
          const r = rand(Rmin, Rmax) * easeOut(Math.random());
          const a = rand(0, Math.PI*2);
          x = Math.round(CX + r*Math.cos(a) - TW/2);
          y = Math.round(CY + r*Math.sin(a) - th/2);

          x = clamp(x, 0, CW - TW);
          y = clamp(y, 0, CH - th);

          const cand = {x, y, w: TW, h: th};
          ok = placed.every(p => !overlap(cand, p, gap));
          tries++;
        }
        placed.push({x, y, w: TW, h: th});

        const fig = document.createElement('figure');
        fig.className = 'tile';
        fig.style.left = x + 'px';
        fig.style.top  = y + 'px';
        fig.style.width= TW + 'px';
        fig.dataset.index = i;

        const im = document.createElement('img');
        im.alt = `img ${i+1}`;
        im.src = encodeURI(m.src);
        fig.appendChild(im);

        fig.addEventListener('click', ()=> setFocus(i));
        canvas.appendChild(fig);
      });

      function rand(a,b){ return Math.random()*(b-a)+a; }
      function easeOut(t){ return 1 - Math.pow(1-t,2); }
      function overlap(a,b,g){
        return !(a.x + a.w + g <= b.x ||
                 b.x + b.w + g <= a.x ||
                 a.y + a.h + g <= b.y ||
                 b.y + b.h + g <= a.y);
      }
      function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
    }

    function centerScroll(){
      const CW = canvas.scrollWidth;
      const CH = canvas.scrollHeight;
      stage.scrollLeft = Math.max(0, CW/2 - stage.clientWidth/2);
      stage.scrollTop  = Math.max(0, CH/2 - stage.clientHeight/2);
    }

    function setFocus(i){
      i = ((i % metas.length) + metas.length) % metas.length;
      current = i;
      const m = metas[i];
      focusImg.src = encodeURI(m.src);
      focusImg.alt = `image ${i+1}`;
    }

    // Optional: keyboard cycle (simple, still barebones)
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowRight') setFocus(current + 1);
      if (e.key === 'ArrowLeft')  setFocus(current - 1);
    });
  }
  </script>
</body>
</html>
