<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>process artefacts</title>
<meta name="description" content="process lab" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>ð“†‰</text></svg>">

<style>
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: #fff;
    color: #000;
    font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
    overflow: hidden; /* no scroll */
  }

  .wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
  header { padding: 8px 12px; color: #555; border-bottom: 1px solid #e5e5e5; }
  header .sub { color: #666; font-size: 13px; }

  :root{
    --grid: 16px;             /* snap unit */
    --grid-line: #e9e9e9;     /* grid color */
    --hole-pad-x: 48px;       /* keep-out around focus (X) */
    --hole-pad-y: 12px;       /* keep-out around focus (Y) */
  }

  /* crisp grid (no aliasing) */
  .stage{
    position: relative;
    overflow: hidden;
    background:
      repeating-linear-gradient(to right, var(--grid-line) 0 1px, transparent 1px var(--grid)),
      repeating-linear-gradient(to bottom, var(--grid-line) 0 1px, transparent 1px var(--grid));
    background-position: 0 0;
  }

  #canvas { position: relative; width: 100%; height: 100%; }

  /* bare thumbnails and focus */
  .tile { position: absolute; background:#fff; }
  .tile img { display:block; width:100%; height:100%; }
  .focus { position:absolute; background:transparent; }
  .focus img { display:block; width:100%; height:100%; background:transparent; }
</style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="sub">behind the scenes of collaboration, and other cuttings from the work desk.</div>
    </header>

    <main class="stage" id="stage">
      <div id="canvas">
        <figure class="focus" id="focusCard"><img id="focusImg" alt=""></figure>
      </div>
    </main>
  </div>

  <script>
  const IMAGES = [
    "images/process/ADT vision.png",
    "images/process/BMC - design.png",
    "images/process/criteriaforintake.png",
    "images/process/CRM.png",
    "images/process/gaps.png",
    "images/process/ladder.jpg",
    "images/process/ideally.jpg",
    "images/process/curriculum.png",
    "images/process/Datapoints.png",
    "images/process/GNC learning.png",
    "images/process/humaneval.png",
    "images/process/knowledge sharing.png",
    "images/process/Laddering Data.jpg",
    "images/process/manual.png",
    "images/process/medium is msg.png",
    "images/process/Name Parameters.png",
    "images/process/naming systems.png",
    "images/process/ourresources.png",
    "images/process/opp.png",
    "images/process/Persona.jpg",
    "images/process/playground UI.png",
    "images/process/Product Partnerships Data Knowledge.png",
    "images/process/Reach.png",
    "images/process/Reachout if.png",
    "images/process/Rules.png",
    "images/process/scales of a problem.png",
    "images/process/signals.png",
    "images/process/singlesource of truth.png",
    "images/process/dreaming sensing.png",
    "images/process/timeline.png",
    "images/process/types of slides.png",
    "images/process/vendorgrid.png",
    "images/process/whatwedonose.png",
    "images/process/XCapit.png",
    "images/process/x.png"
  ];

  const stage    = document.getElementById('stage');
  const canvas   = document.getElementById('canvas');
  const focusEl  = document.getElementById('focusCard');
  const focusImg = document.getElementById('focusImg');

  const GRID = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid')) || 16;

  // grid-multiple constants
  const EDGE_TL     = GRID/2;     // 8px
  const EDGE_RB     = GRID;       // 16px
  const GAP         = GRID/2;     // 8px
  const HOLE_PAD_X  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hole-pad-x')) || 48;
  const HOLE_PAD_Y  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hole-pad-y')) || 12;
  const THUMB_W     = snap(128);  // 8 columns at 16px

  let metas = [];
  let current = -1;

  Promise.all(IMAGES.map(loadMeta)).then(m=>{
    metas = m;
    build();
    setFocus(randInt(0, metas.length-1));
    window.addEventListener('resize', ()=>{ build(); setFocus(current); });
  });

  function loadMeta(src){
    return new Promise(res=>{
      const img=new Image();
      img.onload=()=>res({src, a:(img.naturalHeight||1000)/(img.naturalWidth||1000)});
      img.onerror=()=>res({src, a:1});
      img.src=encodeURI(src);
    });
  }

  // helpers
  const snap  = v => Math.round(v / GRID) * GRID;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function fitSnappedBox(maxW, maxH, aspect){
    let w = snap(maxW);
    let h = snap(Math.max(GRID, w * aspect));
    if (h > maxH){ h = snap(maxH); w = snap(Math.max(GRID, h / aspect)); }
    return { w, h };
  }

  function positionFocusSnapped(aspect){
    const W = stage.clientWidth;
    const H = stage.clientHeight;
    const { w: fw, h: fh } = fitSnappedBox(W - snap(40), H - snap(90), aspect);
    let left = snap((W - fw)/2);
    let top  = snap((H - fh)/2);
    left = clamp(left, EDGE_TL, Math.max(EDGE_TL, W - fw - EDGE_RB));
    top  = clamp(top,  EDGE_TL, Math.max(EDGE_TL, H - fh - EDGE_RB));
    focusEl.style.left = left+'px'; focusEl.style.top = top+'px';
    focusEl.style.width = fw+'px'; focusEl.style.height = fh+'px';
    return { left, top, fw, fh };
  }

  function build(){
    // clear thumbnails
    [...canvas.querySelectorAll('.tile')].forEach(n=>n.remove());

    const W = stage.clientWidth;
    const H = stage.clientHeight;

    // provisional focus box (16:9) to carve hole before we know the chosen image
    const { w: fw0, h: fh0 } = fitSnappedBox(W - snap(40), H - snap(90), 9/16);
    const fx0 = snap((W - fw0)/2);
    const fy0 = snap((H - fh0)/2);

    // hole rect (snapped)
    const hole = {
      x: snap(fx0 - HOLE_PAD_X),
      y: snap(fy0 - HOLE_PAD_Y),
      w: snap(fw0 + HOLE_PAD_X*2),
      h: snap(fh0 + HOLE_PAD_Y*2)
    };

    // Build a grid-occupancy map in cell units
    const cols = Math.floor((W - EDGE_TL - EDGE_RB) / GRID);
    const rows = Math.floor((H - EDGE_TL - EDGE_RB) / GRID);
    const occ  = Array.from({length: rows}, ()=> Array(cols).fill(false));

    // mark a rect (in px) as occupied in the occ grid
    function occupyPxRect(rx, ry, rw, rh){
      const c0 = Math.max(0, Math.floor((rx - EDGE_TL)/GRID));
      const r0 = Math.max(0, Math.floor((ry - EDGE_TL)/GRID));
      const c1 = Math.min(cols-1, Math.ceil((rx + rw - EDGE_TL)/GRID) - 1);
      const r1 = Math.min(rows-1, Math.ceil((ry + rh - EDGE_TL)/GRID) - 1);
      for(let r=r0; r<=r1; r++) for(let c=c0; c<=c1; c++) occ[r][c]=true;
    }
    // check if a rect (in px) touches any occupied cell
    function isFreePxRect(rx, ry, rw, rh){
      const c0 = Math.max(0, Math.floor((rx - EDGE_TL)/GRID));
      const r0 = Math.max(0, Math.floor((ry - EDGE_TL)/GRID));
      const c1 = Math.min(cols-1, Math.ceil((rx + rw - EDGE_TL)/GRID) - 1);
      const r1 = Math.min(rows-1, Math.ceil((ry + rh - EDGE_TL)/GRID) - 1);
      for(let r=r0; r<=r1; r++) for(let c=c0; c<=c1; c++) if(occ[r][c]) return false;
      return true;
    }

    // occupy the keep-out hole first
    occupyPxRect(hole.x, hole.y, hole.w, hole.h);

    // place thumbnails by scanning free cell blocks (no overlap possible)
    metas.forEach((m, i)=>{
      const TW = snap(THUMB_W);
      const TH = snap(Math.max(GRID, TW * m.a)); // preserve aspect, snapped

      // try random starting cells, then scan forward
      let placed = false;
      const tries = 800;
      for(let t=0; t<tries && !placed; t++){
        // random snapped coords in px within bounds
        let rx = snap(randInt(EDGE_TL, Math.max(EDGE_TL, W - TW - EDGE_RB)));
        let ry = snap(randInt(EDGE_TL, Math.max(EDGE_TL, H - TH - EDGE_RB)));

        // scan in a small spiral-ish pattern to find nearest free block
        const step = GRID;
        for(let ring=0; ring<6 && !placed; ring++){
          for(let dy=-ring; dy<=ring && !placed; dy++){
            for(let dx=-ring; dx<=ring && !placed; dx++){
              const x = clamp(snap(rx + dx*step), EDGE_TL, W - TW - EDGE_RB);
              const y = clamp(snap(ry + dy*step), EDGE_TL, H - TH - EDGE_RB);
              // must NOT intersect hole and must be free in occ grid
              const intersectsHole = !(x + TW + GAP <= hole.x ||
                                       hole.x + hole.w + GAP <= x ||
                                       y + TH + GAP <= hole.y ||
                                       hole.y + hole.h + GAP <= y);
              if (!intersectsHole && isFreePxRect(x, y, TW, TH)){
                placeThumb(i, x, y, TW, TH);
                occupyPxRect(x, y, TW, TH);
                placed = true;
              }
            }
          }
        }
      }
      // if still not placed (super tight screens), last-resort: skip
      if (!placed){
        // noop: avoid overlap rather than forcing
      }
    });
  }

  function placeThumb(i, x, y, w, h){
    const fig = document.createElement('figure');
    fig.className = 'tile';
    fig.style.left = x+'px'; fig.style.top = y+'px';
    fig.style.width = w+'px'; fig.style.height = h+'px';
    fig.dataset.index = i;

    const im = document.createElement('img');
    im.alt = `img ${i+1}`; im.src = encodeURI(metas[i].src);
    fig.appendChild(im);
    fig.addEventListener('click', ()=> setFocus(i));
    canvas.appendChild(fig);
  }

  function setFocus(i){
    current = ((i % metas.length) + metas.length) % metas.length;
    const m = metas[current];
    focusImg.src = encodeURI(m.src);
    focusImg.alt = `image ${current+1}`;
    positionFocusSnapped(m.a); // use real aspect; box edges land exactly on grid
  }
  </script>
</body>
</html>
