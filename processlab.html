<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>making of the sausage</title>
<meta name="description" content="artefacts from work - out of context" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>âœ§</text></svg>">

<style>
  :root{
    --bg:#fff; --fg:#111;

    /* scatter tuning */
    --page-pad: 24px;   /* side padding */
    --gap: 18px;        /* space between items (no overlap buffer) */
    --min-w: 260px;     /* min image width on desktop */
    --max-w: 560px;     /* max image width on desktop */

    /* canvas height: JS uses a base "screens" multiplier; this is purely visual vars */
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    -webkit-text-size-adjust: 100%;
  }

  /* Desktop-only wrapper */
  .wrap {
    display: grid;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }
  header {
    padding: 14px max(var(--page-pad), env(safe-area-inset-left)) 6px max(var(--page-pad), env(safe-area-inset-right));
    color: #777; letter-spacing: .25px;
  }

  /* Scrollable stage */
  .stage {
    position: relative;
    overflow: auto;
    padding: 0 var(--page-pad);
    background: #fff;
  }

  /* Giant relative canvas we scatter onto */
  #canvas {
    position: relative;
    width: 100%;
    /* height set by JS */
  }

  /* Each figure is absolutely positioned, clean edges */
  .tile {
    position: absolute;
    margin: 0;
    user-select: none;
    -webkit-user-drag: none;
    touch-action: none;
  }
  .tile img {
    display: block;
    width: 100%;
    height: auto;
    pointer-events: none;
    background: #fff; /* in case of transparent PNGs */
  }

  /* Mobile/tablet: only show the banner */
  .mobile-only {
    display: none;
    position: fixed;
    inset: 0;
    place-items: center;
    text-align: center;
    padding: 24px;
    background: #fff;
    color: #111;
  }
  @media (hover: none) and (pointer: coarse) {
    .wrap { display: none; }
    .mobile-only { display: grid; }
  }

  @media (max-width: 1200px) {
    :root{ --min-w: 220px; --max-w: 460px; }
  }
  @media (max-width: 900px) {
    /* not used (mobile shows banner), but keeps things reasonable for narrow desktop windows */
    :root{ --min-w: 200px; --max-w: 400px; }
  }
</style>
</head>

<body>
  <!-- Desktop content -->
  <div class="wrap">
    <header>screenshots from the desktop, out of context</header>
    <main class="stage" id="stage">
      <div id="canvas" aria-label="Scattered artefacts (no overlap)"></div>
    </main>
  </div>

  <!-- Mobile/tablet message -->
  <div class="mobile-only">view on desktop</div>

  <script>
    // Image list
    const IMAGES = [
      "images/process/ADT vision.png",
      "images/process/Concentric.png",
      "images/process/criteriaforintake.png",
      "images/process/CRM.png",
      "images/process/cryptotransfer.png",
      "images/process/curriculum.png",
      "images/process/Datapoints.png",
      "images/process/GNC learning.png",
      "images/process/humaneval.png",
      "images/process/knowledge sharing.png",
      "images/process/Laddering Data.jpg",
      "images/process/manual.png",
      "images/process/medium is msg.png",
      "images/process/Name Parameters.png",
      "images/process/naming systems.png",
      "images/process/ORG.png",
      "images/process/ourresources.png",
      "images/process/opp.png",
      "images/process/Persona.jpg",
      "images/process/playground UI.png",
      "images/process/Product Partnerships Data Knowledge.png",
      "images/process/Reach.png",
      "images/process/Reachout if.png",
      "images/process/Rules.png",
      "images/process/scales of a problem.png",
      "images/process/timeline.png",
      "images/process/types of slides.png",
      "images/process/vendorgrid.png",
      "images/process/whatwedonose.png",
      "images/process/ideally.jpg",
      "images/process/gov.jpg",
      "images/process/XCapit.png"
    ];

    // Skip building on touch devices (banner shows instead)
    const isTouch = matchMedia("(hover: none) and (pointer: coarse)").matches;
    if (!isTouch) {
      const stage  = document.getElementById('stage');
      const canvas = document.getElementById('canvas');

      const css     = getComputedStyle(document.documentElement);
      const GAP     = parseInt(css.getPropertyValue('--gap'))    || 18;
      const MIN_W_0 = parseInt(css.getPropertyValue('--min-w'))  || 300;
      const MAX_W_0 = parseInt(css.getPropertyValue('--max-w'))  || 700;
      const PAD     = parseInt(css.getPropertyValue('--page-pad'))|| 24;

      // Load all images first to get real aspect ratios
      Promise.all(IMAGES.map(loadMeta)).then(metas => {
        // Layout once (and on resize)
        const doLayout = () => layoutScatter(metas);
        let raf = null;
        const schedule = () => { cancelAnimationFrame(raf); raf = requestAnimationFrame(doLayout); };

        doLayout();
        window.addEventListener('resize', schedule, { passive:true });
      });

      function loadMeta(src) {
        return new Promise((res) => {
          const img = new Image();
          img.loading = 'eager';
          img.decoding = 'async';
          img.onload = () => res({ src, w: img.naturalWidth, h: img.naturalHeight, aspect: img.naturalWidth ? img.naturalHeight / img.naturalWidth : 1 });
          img.onerror = () => res({ src, w: 1000, h: 600, aspect: 0.6 }); // fallback guess
          img.src = encodeURI(src);
        });
      }

      function layoutScatter(metas) {
        canvas.innerHTML = "";
        const W = stage.clientWidth - PAD * 2; // usable inner width
        const MIN_W = Math.min(MIN_W_0, Math.max(160, W * 0.25));
        const MAX_W = Math.max(MIN_W + 40, Math.min(MAX_W_0, W * 0.8));

        // Make the canvas tall: ~6 images per viewport tall; at least 4 screens
        const Hview   = stage.clientHeight || window.innerHeight;
        const screens = Math.max(4, Math.ceil(metas.length / 6));
        let canvasH   = Math.round(screens * Hview);

        // Keep placed rects for collision checks
        const rects = [];
        const figs  = [];

        // Utility: overlap check with gap
        const overlap = (a, b, gap=GAP) => {
          return !(
            a.x + a.w + gap <= b.x ||
            b.x + b.w + gap <= a.x ||
            a.y + a.h + gap <= b.y ||
            b.y + b.h + gap <= a.y
          );
        };

        // Try to place each image; if it can't fit after many tries, extend canvas height
        metas.forEach((m, i) => {
          // Random width, compute height from aspect
          const w = clamp(rand(MIN_W, MAX_W), MIN_W, MAX_W);
          const h = Math.round(w * (m.aspect || 0.7));
          let tries = 0, placed = false, x=0, y=0;

          while (!placed && tries < 200) {
            x = Math.round(rand(PAD, Math.max(PAD, W - w - PAD)));
            y = Math.round(rand(GAP, Math.max(GAP, canvasH - h - GAP)));

            const r = { x, y, w, h };
            let ok = true;
            for (let j = 0; j < rects.length; j++) {
              if (overlap(r, rects[j])) { ok = false; break; }
            }
            if (ok) {
              rects.push(r);
              placed = true;
            } else {
              tries++;
              // If struggling a lot, grow the canvas a bit to give room
              if (tries === 120 || tries === 180) canvasH += Math.round(Hview * 0.5);
            }
          }

          // Create DOM
          const fig = document.createElement('figure');
          fig.className = 'tile';
          fig.style.width = w + 'px';
          fig.style.left  = x + 'px';
          fig.style.top   = y + 'px';

          const img = document.createElement('img');
          img.alt = `artefact ${i+1}`;
          img.src = encodeURI(m.src);
          fig.appendChild(img);
          figs.push(fig);
        });

        // Set final canvas height and append nodes
        canvas.style.height = canvasH + 'px';
        figs.forEach(f => canvas.appendChild(f));
      }

      // Helpers
      function rand(a, b) { return Math.random() * (b - a) + a; }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    }
  </script>
</body>
</html>
