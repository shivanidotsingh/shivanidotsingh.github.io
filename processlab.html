<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>process is the practice</title>
<meta name="description" content="miro board" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>ðŸŒ€</text></svg>">

<style>
  :root{
    --bg:#f2f2f2; --fg:#111;

    /* SCATTER KNOBS */
    --page-pad: 28px;   /* page side padding */
    --gap: 16px;        /* initial spacing buffer between items */
    --min-w: 300px;     /* starting width range (desktop)  âŸµ you asked larger */
    --max-w: 700px;     /* starting width range (desktop)  âŸµ you asked larger */
    --size-bias: 1.20;  /* global multiplier for default size (1.0 = no change) */

    /* DRAG/RESIZE */
    --tile-shadow: 0 0 0 1px rgba(0,0,0,.06);
    --handle-size: 14px; /* resize handle square size */
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  }

  /* Desktop-only wrapper */
  .wrap {
    display: grid;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }
  header {
    padding: 14px max(var(--page-pad), env(safe-area-inset-left)) 6px max(var(--page-pad), env(safe-area-inset-right));
    color: #777; letter-spacing: .25px;
  }

  /* Scrollable stage */
  .stage {
    position: relative;
    overflow: auto;
    padding: 0 var(--page-pad);
    background: #f2f2f2;
    -webkit-user-select: none; user-select: none;
  }

  /* The tall canvas we place tiles on */
  #canvas {
    position: relative;
    width: 100%;
    /* JS sets height */
  }

  /* Tiles */
  .tile {
    position: absolute;
    margin: 0;
    user-select: none;
    -webkit-user-drag: none;
    touch-action: none; /* so pointer events are precise */
    cursor: grab;
    box-shadow: var(--tile-shadow);
  }
  .tile.dragging { cursor: grabbing; }
  .tile img {
    display: block; width: 100%; height: auto; pointer-events: none;
  }

  /* Resize handle (bottom-right) */
  .handle {
    position: absolute;
    width: var(--handle-size);
    height: var(--handle-size);
    right: -6px; bottom: -6px;
    border: 1px solid #ccc;
    background: #fff;
    cursor: nwse-resize;
  }

  /* Mobile/tablet: only show the banner */
  .mobile-only {
    display: none;
    position: fixed; inset: 0;
    place-items: center;
    text-align: center;
    padding: 24px; background: #fff; color: #111;
  }
  @media (hover: none) and (pointer: coarse) {
    .wrap { display: none; }
    .mobile-only { display: grid; }
  }
</style>
</head>

<body>
  <!-- Desktop content -->
  <div class="wrap">
    <header>making thinking visible, from the process of collaboration</header>
    <main class="stage" id="stage">
      <div id="canvas" aria-label="Scattered artefacts (draggable & resizable)"></div>
    </main>
  </div>

  <!-- Mobile/tablet message -->
  <div class="mobile-only">view on desktop</div>

  <script>
    // Image list
    const IMAGES = [
      "images/process/ADT vision.png",
      "images/process/Concentric.png",
      "images/process/criteriaforintake.png",
      "images/process/CRM.png",
      "images/process/ladder.jpg",
      "images/process/cryptotransfer.png",
      "images/process/ideally.jpg",
      "images/process/curriculum.png",
      "images/process/Datapoints.png",
      "images/process/GNC learning.png",
      "images/process/humaneval.png",
      "images/process/knowledge sharing.png",
      "images/process/Laddering Data.jpg",
      "images/process/manual.png",
      "images/process/medium is msg.png",
      "images/process/Name Parameters.png",
      "images/process/naming systems.png",
      "images/process/ORG.png",
      "images/process/ourresources.png",
      "images/process/opp.png",
      "images/process/Persona.jpg",
      "images/process/playground UI.png",
      "images/process/Product Partnerships Data Knowledge.png",
      "images/process/Reach.png",
      "images/process/Reachout if.png",
      "images/process/Rules.png",
      "images/process/scales of a problem.png",
      "images/process/timeline.png",
      "images/process/types of slides.png",
      "images/process/vendorgrid.png",
      "images/process/whatwedonose.png",
      "images/process/XCapit.png"
    ];

    // Skip building on touch devices (banner shows instead)
    const isTouch = matchMedia("(hover: none) and (pointer: coarse)").matches;
    if (!isTouch) {
      const stage  = document.getElementById('stage');
      const canvas = document.getElementById('canvas');

      const css       = getComputedStyle(document.documentElement);
      const GAP       = parseInt(css.getPropertyValue('--gap'))        || 16;
      const MIN_W_0   = parseInt(css.getPropertyValue('--min-w'))      || 300;
      const MAX_W_0   = parseInt(css.getPropertyValue('--max-w'))      || 700;
      const PAD       = parseInt(css.getPropertyValue('--page-pad'))   || 28;
      const SIZE_BIAS = parseFloat(css.getPropertyValue('--size-bias'))|| 1.2;

      const rand   = (a, b) => Math.random() * (b - a) + a;
      const clamp  = (v, a, b) => Math.max(a, Math.min(b, v));

      // 1) Load images to know aspects
      Promise.all(IMAGES.map(loadMeta)).then(metas => {
        build(metas);
        // Relayout on resize (re-randomizes positions to fit new width/height)
        let rid = null;
        window.addEventListener('resize', () => {
          cancelAnimationFrame(rid);
          rid = requestAnimationFrame(() => build(metas));
        }, { passive:true });
      });

      function loadMeta(src) {
        return new Promise((res) => {
          const img = new Image();
          img.loading = 'eager';
          img.decoding = 'async';
          img.onload = () => res({ src, w: img.naturalWidth, h: img.naturalHeight, aspect: img.naturalWidth ? img.naturalHeight / img.naturalWidth : 0.7 });
          img.onerror = () => res({ src, w: 1200, h: 800, aspect: 800/1200 });
          img.src = encodeURI(src);
        });
      }

      // 2) Initial scatter layout (no overlap), then enable drag+resize
      function build(metas){
        canvas.innerHTML = "";

        const W = stage.clientWidth - PAD * 2;           // usable width
        const Hview = stage.clientHeight || innerHeight; // viewport height
        const MIN_W = Math.min(MIN_W_0, Math.max(160, W * 0.25));
        const MAX_W = Math.max(MIN_W + 40, Math.min(MAX_W_0, W * 0.9));

        // Make it tall: ~6 images per screen; at least 4 screens
        const screensBase = Math.max(4, Math.ceil(metas.length / 6));
        let canvasH = Math.round(screensBase * Hview);

        const rects = [];
        let zTop = 10;

        // place each image
        metas.forEach((m, i) => {
          // random width within range, biased larger
          const w0 = clamp(rand(MIN_W, MAX_W) * SIZE_BIAS, MIN_W, MAX_W);
          const h0 = Math.round(w0 * (m.aspect || 0.7));

          // find a spot that doesn't overlap earlier rects
          let x=0, y=0, tries=0, ok=false;
          while (!ok && tries < 220) {
            x = Math.round(rand(PAD, Math.max(PAD, W - w0 - PAD)));
            y = Math.round(rand(GAP, Math.max(GAP, canvasH - h0 - GAP)));
            const r = { x, y, w:w0, h:h0 };
            ok = rects.every(prev => !overlap(r, prev, GAP));
            if (!ok) {
              tries++;
              if (tries === 150) canvasH += Math.round(Hview * 0.5); // give more room if crowded
            } else {
              rects.push(r);
            }
          }

          // DOM
          const fig = document.createElement('figure');
          fig.className = 'tile';
          fig.style.left = x + 'px';
          fig.style.top  = y + 'px';
          fig.style.width = w0 + 'px';
          fig.style.zIndex = (++zTop).toString();

          // content
          const img = document.createElement('img');
          img.alt = `artefact ${i+1}`;
          img.src = encodeURI(m.src);
          fig.appendChild(img);

          // handle
          const handle = document.createElement('div');
          handle.className = 'handle';
          fig.appendChild(handle);

          // store state on element
          fig._state = {
            aspect: m.aspect || 0.7,
            minW: Math.max(160, MIN_W),  // do not go too tiny
            maxW: Math.max(MIN_W + 40, Math.min(MAX_W, W * 0.95)), // safety
          };

          canvas.appendChild(fig);

          enableDrag(fig);
          enableResize(fig, handle);
        });

        canvas.style.height = canvasH + 'px';

        // helpers
        function overlap(a, b, gap){
          return !(
            a.x + a.w + gap <= b.x ||
            b.x + b.w + gap <= a.x ||
            a.y + a.h + gap <= b.y ||
            b.y + b.h + gap <= a.y
          );
        }

        function keepInBounds(el){
          // keep tile within canvas bounds after drag/resize
          const w = el.offsetWidth;
          const h = el.offsetHeight;
          const maxX = Math.max(0, (stage.clientWidth - PAD*2) - w - PAD);
          const maxY = Math.max(0, (parseInt(canvas.style.height)||canvas.scrollHeight) - h - 8);
          const x = clamp(parseFloat(el.style.left)||0, PAD, maxX);
          const y = clamp(parseFloat(el.style.top)||0,  0,   maxY);
          el.style.left = x + 'px';
          el.style.top  = y + 'px';
        }

        function enableDrag(el){
          let pid=null, sx=0, sy=0, ox=0, oy=0;
          el.addEventListener('pointerdown', (e) => {
            if (e.target.classList.contains('handle')) return; // resize takes precedence
            pid = e.pointerId;
            el.setPointerCapture(pid);
            sx = e.clientX; sy = e.clientY;
            ox = parseFloat(el.style.left)||0; oy = parseFloat(el.style.top)||0;
            el.classList.add('dragging');
            el.style.zIndex = (++zTop).toString();
            e.preventDefault();
          });
          el.addEventListener('pointermove', (e) => {
            if (e.pointerId !== pid) return;
            const nx = ox + (e.clientX - sx);
            const ny = oy + (e.clientY - sy);
            el.style.left = nx + 'px';
            el.style.top  = ny + 'px';
          });
          const end = () => { pid=null; el.classList.remove('dragging'); keepInBounds(el); };
          el.addEventListener('pointerup', end);
          el.addEventListener('pointercancel', end);
          el.addEventListener('lostpointercapture', end);
        }

        function enableResize(el, handle){
          let pid=null, sx=0, sy=0, startW=0, startH=0;
          handle.addEventListener('pointerdown', (e) => {
            pid = e.pointerId;
            handle.setPointerCapture(pid);
            sx = e.clientX; sy = e.clientY;
            startW = el.offsetWidth; startH = el.offsetHeight;
            el.style.zIndex = (++zTop).toString();
            e.preventDefault();
            e.stopPropagation();
          });
          handle.addEventListener('pointermove', (e) => {
            if (e.pointerId !== pid) return;
            const dx = e.clientX - sx;
            // Resize with aspect lock using width as driver
            const st = el._state;
            let w = clamp(startW + dx, st.minW, st.maxW);
            let h = Math.round(w * st.aspect);
            el.style.width = w + 'px';
            el.style.height = h + 'px'; // height will be dictated by image ratio, but set for bounds
          });
          const end = () => {
            if (pid==null) return;
            pid=null;
            keepInBounds(el);
          };
          handle.addEventListener('pointerup', end);
          handle.addEventListener('pointercancel', end);
          handle.addEventListener('lostpointercapture', end);
        }
      }
    }
  </script>
</body>
</html>
