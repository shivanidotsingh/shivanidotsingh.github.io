<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>facilitation archives</title>
<meta name="description" content="miro board" />
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='86'>ðŸŒ€</text></svg>">

<style>
  :root{
    --bg:#ffffff; --fg:#111;

    /* GRID (cutting-mat vibe) */
    --grid: 16px;                         /* base grid size */
    --grid-sub: #f6f6f6;                  /* tiny cells */
    --grid-main: #efefef;                 /* every 4th line */

    /* LAYOUT */
    --side-gutter: 32px;                  /* visual gutters left/right */
    --gap: 12px;                          /* spacing between tiles (tight) */

    /* DRAG */
    --tile-shadow: 0 0 0 1px rgba(0,0,0,.06);
  }

  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  }

  .wrap{
    display:grid;
    grid-template-rows:auto 1fr;
    height:100vh;
  }
  header{
    padding:14px max(var(--side-gutter), env(safe-area-inset-left)) 6px max(var(--side-gutter), env(safe-area-inset-right));
    color:#777; letter-spacing:.25px;
  }

  /* Stage spans full width; grid drawn across the whole area */
  .stage{
    position:relative;
    overflow:auto;
    padding:0 var(--side-gutter); /* gutters here so every grid col is usable */
    background:
      /* sub grid */
      linear-gradient(var(--grid-sub) 1px, transparent 1px) 0 0/100% var(--grid),
      linear-gradient(90deg, var(--grid-sub) 1px, transparent 1px) 0 0/var(--grid) 100%,
      /* main grid (every 4 lines) */
      linear-gradient(var(--grid-main) 1px, transparent 1px) 0 0/100% calc(var(--grid)*4),
      linear-gradient(90deg, var(--grid-main) 1px, transparent 1px) 0 0/calc(var(--grid)*4) 100%,
      #fff;
    -webkit-user-select:none; user-select:none;
  }

  /* Canvas uses full stage width inside gutters */
  #canvas{ position:relative; width:100%; }

  .tile{
    position:absolute;
    margin:0;
    user-select:none; -webkit-user-drag:none; touch-action:none;
    cursor:grab;
    box-shadow:var(--tile-shadow);
    background:#fff;
    will-change:left, top, width, height;
    transform:translateZ(0);
  }
  .tile.dragging{ cursor:grabbing; }
  .tile img{ display:block; width:100%; height:auto; pointer-events:none; }

  /* Phones: show banner */
  .mobile-only{
    display:none; position:fixed; inset:0;
    place-items:center; text-align:center; padding:24px; background:#fff; color:#111;
  }
  @media (max-width:767px){
    .wrap{ display:none; }
    .mobile-only{ display:grid; }
  }
</style>
</head>

<body>
  <div class="wrap">
    <header>behind the scenes of collaboration, and other cuttings from the work desk.</header>
    <main class="stage" id="stage">
      <div id="canvas" aria-label="Grid-snapped artefacts (tight; consistent sizes; no overlaps)"></div>
    </main>
  </div>
  <div class="mobile-only">view on desktop</div>

  <script>
  /* ---- Your images ---- */
  const IMAGES = [
    "images/process/ADT vision.png",
    "images/process/Concentric.png",
    "images/process/BMC - design.png",
    "images/process/criteriaforintake.png",
    "images/process/CRM.png",
    "images/process/gaps.png",
    "images/process/ladder.jpg",
    "images/process/ideally.jpg",
    "images/process/curriculum.png",
    "images/process/Datapoints.png",
    "images/process/GNC learning.png",
    "images/process/humaneval.png",
    "images/process/knowledge sharing.png",
    "images/process/Laddering Data.jpg",
    "images/process/manual.png",
    "images/process/medium is msg.png",
    "images/process/Name Parameters.png",
    "images/process/naming systems.png",
    "images/process/ORG.png",
    "images/process/ourresources.png",
    "images/process/opp.png",
    "images/process/Persona.jpg",
    "images/process/playground UI.png",
    "images/process/Product Partnerships Data Knowledge.png",
    "images/process/Reach.png",
    "images/process/Reachout if.png",
    "images/process/Rules.png",
    "images/process/scales of a problem.png",
    "images/process/signals.png",
    "images/process/singlesource of truth.png",
    "images/process/dreaming sensing.png",
    "images/process/timeline.png",
    "images/process/types of slides.png",
    "images/process/vendorgrid.png",
    "images/process/whatwedonose.png",
    "images/process/XCapit.png",
    "images/process/x.png"
  ];

  /* ---- Phone gate ---- */
  const isPhone = matchMedia("(max-width: 767px)").matches;
  if (!isPhone){
    const stage  = document.getElementById('stage');
    const canvas = document.getElementById('canvas');

    const css   = getComputedStyle(document.documentElement);
    const GRID  = parseInt(css.getPropertyValue('--grid')) || 16;
    const GAP   = parseInt(css.getPropertyValue('--gap'))  || 12;

    /* Sizing policy (edit these) */
    const WIDE_W      = 720;   // landscape width (px)
    const NARROW_W    = 480;   // square-ish width (px)
    const PORTRAIT_W  = 480;   // portrait width (px)
    const SQUARE_EPS  = 0.12;  // |aspect - 1| <= eps => square-ish

    const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

    // load aspects
    Promise.all(IMAGES.map(loadMeta)).then(metas=>{
      build(metas);
      let rid=null;
      window.addEventListener('resize', ()=>{ cancelAnimationFrame(rid); rid=requestAnimationFrame(()=>build(metas)); }, {passive:true});
    });

    function loadMeta(src){
      return new Promise(res=>{
        const img=new Image();
        img.loading='eager'; img.decoding='async';
        img.onload=()=>res({src, aspect: img.naturalWidth? img.naturalHeight/img.naturalWidth:1});
        img.onerror=()=>res({src, aspect:1});
        img.src=encodeURI(src);
      });
    }

    // helpers
    const toCells = px => Math.max(1, Math.round(px/GRID));
    const toPx    = c  => c*GRID;

    function desiredWidthFor(aspect){
      // aspect = h/w
      if (Math.abs(aspect - 1) <= SQUARE_EPS) return NARROW_W;   // square-ish
      if (aspect < 1) return WIDE_W;                              // landscape
      return PORTRAIT_W;                                          // portrait
    }

    /* --------- initial tight packing (skyline / no overlap) --------- */
    function build(metas){
      canvas.innerHTML="";

      const innerW = canvas.clientWidth;           // actual usable width
      const cols   = Math.max(8, Math.floor(innerW / GRID));
      const gapC   = toCells(GAP);

      // skyline heights by column
      const colHeights = new Array(cols).fill(0);

      // estimate canvas height (will grow as needed)
      const Hview = stage.clientHeight || innerHeight;
      let canvasH = Math.ceil((4*Hview)/GRID) * GRID;

      // place in natural order for now (keeps feel predictable)
      metas.forEach((m,i)=>{
        // consistent width by category, then snap to grid column multiple
        const targetW = desiredWidthFor(m.aspect);
        const wc = Math.max(2, toCells(targetW));
        const wpx = toPx(wc);
        const hpx = Math.round(wpx * (m.aspect || 1));
        const hr  = Math.max(2, toCells(hpx)) + gapC;

        // choose column span with lowest skyline
        let bestCol = 0, bestY = Infinity;
        for (let c=0; c<=cols-wc; c++){
          let y = 0;
          for (let k=0;k<wc;k++) y = Math.max(y, colHeights[c+k]);
          if (y < bestY) { bestY = y; bestCol = c; }
        }

        const left = toPx(bestCol);
        const top  = toPx(bestY);

        // update skyline
        for (let k=0;k<wc;k++) colHeights[bestCol+k] = bestY + hr;

        // grow canvas if needed
        canvasH = Math.max(canvasH, toPx(bestY + hr));

        // DOM
        const fig = document.createElement('figure');
        fig.className='tile';
        fig.style.left = left + 'px';
        fig.style.top  = top  + 'px';
        fig.style.width= wpx  + 'px';
        fig.style.zIndex = (10+i).toString();

        const img = document.createElement('img');
        img.alt = `artefact ${i+1}`;
        img.src = encodeURI(m.src);
        fig.appendChild(img);

        // state for interactions
        fig._state = { aspect: m.aspect || 1, GRID };

        canvas.appendChild(fig);

        // drag with snap + no overlap
        enableDragSnapNoOverlap(fig);
      });

      canvas.style.height = canvasH + 'px';
    }

    /* ---------- drag: free-move; on release -> snap to grid + reject overlaps ---------- */
    function readRects(excludeEl=null){
      const rects=[];
      canvas.querySelectorAll('.tile').forEach(el=>{
        if (el===excludeEl) return;
        rects.push({
          el,
          x: parseFloat(el.style.left)||0,
          y: parseFloat(el.style.top)||0,
          w: el.offsetWidth,
          h: el.offsetHeight
        });
      });
      return rects;
    }
    function intersects(a,b){
      return !(a.x+a.w <= b.x || b.x+b.w <= a.x || a.y+a.h <= b.y || b.y+b.h <= a.y);
    }

    function enableDragSnapNoOverlap(el){
      let pid=null, sx=0, sy=0, ox=0, oy=0, prev={x:0,y:0,w:0,h:0};

      el.addEventListener('pointerdown', (e)=>{
        pid = e.pointerId; el.setPointerCapture(pid);
        sx = e.clientX; sy = e.clientY;
        ox = parseFloat(el.style.left)||0; oy = parseFloat(el.style.top)||0;
        prev = { x:ox, y:oy, w: el.offsetWidth, h: el.offsetHeight };
        el.classList.add('dragging');
        el.style.zIndex = (parseInt(el.style.zIndex)||10)+1;
        if (e.cancelable) e.preventDefault();
      });

      el.addEventListener('pointermove', (e)=>{
        if (e.pointerId !== pid) return;
        const nx = ox + (e.clientX - sx);
        const ny = oy + (e.clientY - sy);
        // clamp to canvas bounds, no snap yet
        const maxX = canvas.clientWidth - el.offsetWidth;
        const maxY = (parseInt(canvas.style.height)||canvas.scrollHeight||canvas.clientHeight) - el.offsetHeight;
        el.style.left = clamp(nx, 0, Math.max(0,maxX)) + 'px';
        el.style.top  = clamp(ny, 0, Math.max(0,maxY)) + 'px';
      });

      const end = ()=>{
        if (pid==null) return;
        pid=null; el.classList.remove('dragging');

        // snap pos to grid
        let nx = Math.round((parseFloat(el.style.left)||0)/el._state.GRID)*el._state.GRID;
        let ny = Math.round((parseFloat(el.style.top)||0)/el._state.GRID)*el._state.GRID;
        // clamp after snap
        const maxX = canvas.clientWidth - el.offsetWidth;
        const maxY = (parseInt(canvas.style.height)||canvas.scrollHeight||canvas.clientHeight) - el.offsetHeight;
        nx = clamp(nx, 0, Math.max(0,maxX));
        ny = clamp(ny, 0, Math.max(0,maxY));

        // overlap check
        const others = readRects(el);
        const candidate = { x:nx, y:ny, w: el.offsetWidth, h: el.offsetHeight };
        const hit = others.some(r=>intersects(candidate, r));

        if (hit){
          // revert to previous valid position
          el.style.left = prev.x + 'px';
          el.style.top  = prev.y + 'px';
        } else {
          el.style.left = nx + 'px';
          el.style.top  = ny + 'px';
        }
      };

      el.addEventListener('pointerup', end);
      el.addEventListener('pointercancel', end);
      el.addEventListener('lostpointercapture', end);
    }
  }
  </script>
</body>
</html>
